<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title></title>
<meta name="author" content="(Aldric Giacomoni)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<style type="text/css">
/*!
 * reveal.js
 * http://revealjs.com
 * MIT licensed
 *
 * Copyright (C) 2017 Hakim El Hattab, http://hakim.se
 */
/*********************************************
 * RESET STYLES
 *********************************************/
html, body, .reveal div, .reveal span, .reveal applet, .reveal object, .reveal iframe,
.reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6, .reveal p, .reveal blockquote, .reveal pre,
.reveal a, .reveal abbr, .reveal acronym, .reveal address, .reveal big, .reveal cite, .reveal code,
.reveal del, .reveal dfn, .reveal em, .reveal img, .reveal ins, .reveal kbd, .reveal q, .reveal s, .reveal samp,
.reveal small, .reveal strike, .reveal strong, .reveal sub, .reveal sup, .reveal tt, .reveal var,
.reveal b, .reveal u, .reveal center,
.reveal dl, .reveal dt, .reveal dd, .reveal ol, .reveal ul, .reveal li,
.reveal fieldset, .reveal form, .reveal label, .reveal legend,
.reveal table, .reveal caption, .reveal tbody, .reveal tfoot, .reveal thead, .reveal tr, .reveal th, .reveal td,
.reveal article, .reveal aside, .reveal canvas, .reveal details, .reveal embed,
.reveal figure, .reveal figcaption, .reveal footer, .reveal header, .reveal hgroup,
.reveal menu, .reveal nav, .reveal output, .reveal ruby, .reveal section, .reveal summary,
.reveal time, .reveal mark, .reveal audio, .reveal video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline; }

.reveal article, .reveal aside, .reveal details, .reveal figcaption, .reveal figure,
.reveal footer, .reveal header, .reveal hgroup, .reveal menu, .reveal nav, .reveal section {
  display: block; }

/*********************************************
 * GLOBAL STYLES
 *********************************************/
html,
body {
  width: 100%;
  height: 100%;
  overflow: hidden; }

body {
  position: relative;
  line-height: 1;
  background-color: #fff;
  color: #000; }

/*********************************************
 * VIEW FRAGMENTS
 *********************************************/
.reveal .slides section .fragment {
  opacity: 0;
  visibility: hidden;
  transition: all .2s ease; }
  .reveal .slides section .fragment.visible {
    opacity: 1;
    visibility: inherit; }

.reveal .slides section .fragment.grow {
  opacity: 1;
  visibility: inherit; }
  .reveal .slides section .fragment.grow.visible {
    -webkit-transform: scale(1.3);
            transform: scale(1.3); }

.reveal .slides section .fragment.shrink {
  opacity: 1;
  visibility: inherit; }
  .reveal .slides section .fragment.shrink.visible {
    -webkit-transform: scale(0.7);
            transform: scale(0.7); }

.reveal .slides section .fragment.zoom-in {
  -webkit-transform: scale(0.1);
          transform: scale(0.1); }
  .reveal .slides section .fragment.zoom-in.visible {
    -webkit-transform: none;
            transform: none; }

.reveal .slides section .fragment.fade-out {
  opacity: 1;
  visibility: inherit; }
  .reveal .slides section .fragment.fade-out.visible {
    opacity: 0;
    visibility: hidden; }

.reveal .slides section .fragment.semi-fade-out {
  opacity: 1;
  visibility: inherit; }
  .reveal .slides section .fragment.semi-fade-out.visible {
    opacity: 0.5;
    visibility: inherit; }

.reveal .slides section .fragment.strike {
  opacity: 1;
  visibility: inherit; }
  .reveal .slides section .fragment.strike.visible {
    text-decoration: line-through; }

.reveal .slides section .fragment.fade-up {
  -webkit-transform: translate(0, 20%);
          transform: translate(0, 20%); }
  .reveal .slides section .fragment.fade-up.visible {
    -webkit-transform: translate(0, 0);
            transform: translate(0, 0); }

.reveal .slides section .fragment.fade-down {
  -webkit-transform: translate(0, -20%);
          transform: translate(0, -20%); }
  .reveal .slides section .fragment.fade-down.visible {
    -webkit-transform: translate(0, 0);
            transform: translate(0, 0); }

.reveal .slides section .fragment.fade-right {
  -webkit-transform: translate(-20%, 0);
          transform: translate(-20%, 0); }
  .reveal .slides section .fragment.fade-right.visible {
    -webkit-transform: translate(0, 0);
            transform: translate(0, 0); }

.reveal .slides section .fragment.fade-left {
  -webkit-transform: translate(20%, 0);
          transform: translate(20%, 0); }
  .reveal .slides section .fragment.fade-left.visible {
    -webkit-transform: translate(0, 0);
            transform: translate(0, 0); }

.reveal .slides section .fragment.current-visible {
  opacity: 0;
  visibility: hidden; }
  .reveal .slides section .fragment.current-visible.current-fragment {
    opacity: 1;
    visibility: inherit; }

.reveal .slides section .fragment.highlight-red,
.reveal .slides section .fragment.highlight-current-red,
.reveal .slides section .fragment.highlight-green,
.reveal .slides section .fragment.highlight-current-green,
.reveal .slides section .fragment.highlight-blue,
.reveal .slides section .fragment.highlight-current-blue {
  opacity: 1;
  visibility: inherit; }

.reveal .slides section .fragment.highlight-red.visible {
  color: #ff2c2d; }

.reveal .slides section .fragment.highlight-green.visible {
  color: #17ff2e; }

.reveal .slides section .fragment.highlight-blue.visible {
  color: #1b91ff; }

.reveal .slides section .fragment.highlight-current-red.current-fragment {
  color: #ff2c2d; }

.reveal .slides section .fragment.highlight-current-green.current-fragment {
  color: #17ff2e; }

.reveal .slides section .fragment.highlight-current-blue.current-fragment {
  color: #1b91ff; }

/*********************************************
 * DEFAULT ELEMENT STYLES
 *********************************************/
/* Fixes issue in Chrome where italic fonts did not appear when printing to PDF */
.reveal:after {
  content: '';
  font-style: italic; }

.reveal iframe {
  z-index: 1; }

/** Prevents layering issues in certain browser/transition combinations */
.reveal a {
  position: relative; }

.reveal .stretch {
  max-width: none;
  max-height: none; }

.reveal pre.stretch code {
  height: 100%;
  max-height: 100%;
  box-sizing: border-box; }

/*********************************************
 * CONTROLS
 *********************************************/
@-webkit-keyframes bounce-right {
  0%, 10%, 25%, 40%, 50% {
    -webkit-transform: translateX(0);
            transform: translateX(0); }
  20% {
    -webkit-transform: translateX(10px);
            transform: translateX(10px); }
  30% {
    -webkit-transform: translateX(-5px);
            transform: translateX(-5px); } }
@keyframes bounce-right {
  0%, 10%, 25%, 40%, 50% {
    -webkit-transform: translateX(0);
            transform: translateX(0); }
  20% {
    -webkit-transform: translateX(10px);
            transform: translateX(10px); }
  30% {
    -webkit-transform: translateX(-5px);
            transform: translateX(-5px); } }

@-webkit-keyframes bounce-down {
  0%, 10%, 25%, 40%, 50% {
    -webkit-transform: translateY(0);
            transform: translateY(0); }
  20% {
    -webkit-transform: translateY(10px);
            transform: translateY(10px); }
  30% {
    -webkit-transform: translateY(-5px);
            transform: translateY(-5px); } }

@keyframes bounce-down {
  0%, 10%, 25%, 40%, 50% {
    -webkit-transform: translateY(0);
            transform: translateY(0); }
  20% {
    -webkit-transform: translateY(10px);
            transform: translateY(10px); }
  30% {
    -webkit-transform: translateY(-5px);
            transform: translateY(-5px); } }

.reveal .controls {
  display: none;
  position: absolute;
  top: auto;
  bottom: 12px;
  right: 12px;
  left: auto;
  z-index: 1;
  color: #000;
  pointer-events: none;
  font-size: 10px; }
  .reveal .controls button {
    position: absolute;
    padding: 0;
    background-color: transparent;
    border: 0;
    outline: 0;
    cursor: pointer;
    color: currentColor;
    -webkit-transform: scale(0.9999);
            transform: scale(0.9999);
    transition: color 0.2s ease, opacity 0.2s ease, -webkit-transform 0.2s ease;
    transition: color 0.2s ease, opacity 0.2s ease, transform 0.2s ease;
    z-index: 2;
    pointer-events: auto;
    font-size: inherit;
    visibility: hidden;
    opacity: 0;
    -webkit-appearance: none;
    -webkit-tap-highlight-color: transparent; }
  .reveal .controls .controls-arrow:before,
  .reveal .controls .controls-arrow:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 2.6em;
    height: 0.5em;
    border-radius: 0.25em;
    background-color: currentColor;
    transition: all 0.15s ease, background-color 0.8s ease;
    -webkit-transform-origin: 0.2em 50%;
            transform-origin: 0.2em 50%;
    will-change: transform; }
  .reveal .controls .controls-arrow {
    position: relative;
    width: 3.6em;
    height: 3.6em; }
    .reveal .controls .controls-arrow:before {
      -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(45deg);
              transform: translateX(0.5em) translateY(1.55em) rotate(45deg); }
    .reveal .controls .controls-arrow:after {
      -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(-45deg);
              transform: translateX(0.5em) translateY(1.55em) rotate(-45deg); }
    .reveal .controls .controls-arrow:hover:before {
      -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(40deg);
              transform: translateX(0.5em) translateY(1.55em) rotate(40deg); }
    .reveal .controls .controls-arrow:hover:after {
      -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(-40deg);
              transform: translateX(0.5em) translateY(1.55em) rotate(-40deg); }
    .reveal .controls .controls-arrow:active:before {
      -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(36deg);
              transform: translateX(0.5em) translateY(1.55em) rotate(36deg); }
    .reveal .controls .controls-arrow:active:after {
      -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(-36deg);
              transform: translateX(0.5em) translateY(1.55em) rotate(-36deg); }
  .reveal .controls .navigate-left {
    right: 6.4em;
    bottom: 3.2em;
    -webkit-transform: translateX(-10px);
            transform: translateX(-10px); }
  .reveal .controls .navigate-right {
    right: 0;
    bottom: 3.2em;
    -webkit-transform: translateX(10px);
            transform: translateX(10px); }
    .reveal .controls .navigate-right .controls-arrow {
      -webkit-transform: rotate(180deg);
              transform: rotate(180deg); }
    .reveal .controls .navigate-right.highlight {
      -webkit-animation: bounce-right 2s 50 both ease-out;
              animation: bounce-right 2s 50 both ease-out; }
  .reveal .controls .navigate-up {
    right: 3.2em;
    bottom: 6.4em;
    -webkit-transform: translateY(-10px);
            transform: translateY(-10px); }
    .reveal .controls .navigate-up .controls-arrow {
      -webkit-transform: rotate(90deg);
              transform: rotate(90deg); }
  .reveal .controls .navigate-down {
    right: 3.2em;
    bottom: 0;
    -webkit-transform: translateY(10px);
            transform: translateY(10px); }
    .reveal .controls .navigate-down .controls-arrow {
      -webkit-transform: rotate(-90deg);
              transform: rotate(-90deg); }
    .reveal .controls .navigate-down.highlight {
      -webkit-animation: bounce-down 2s 50 both ease-out;
              animation: bounce-down 2s 50 both ease-out; }
  .reveal .controls[data-controls-back-arrows="faded"] .navigate-left.enabled,
  .reveal .controls[data-controls-back-arrows="faded"] .navigate-up.enabled {
    opacity: 0.3; }
    .reveal .controls[data-controls-back-arrows="faded"] .navigate-left.enabled:hover,
    .reveal .controls[data-controls-back-arrows="faded"] .navigate-up.enabled:hover {
      opacity: 1; }
  .reveal .controls[data-controls-back-arrows="hidden"] .navigate-left.enabled,
  .reveal .controls[data-controls-back-arrows="hidden"] .navigate-up.enabled {
    opacity: 0;
    visibility: hidden; }
  .reveal .controls .enabled {
    visibility: visible;
    opacity: 0.9;
    cursor: pointer;
    -webkit-transform: none;
            transform: none; }
  .reveal .controls .enabled.fragmented {
    opacity: 0.5; }
  .reveal .controls .enabled:hover,
  .reveal .controls .enabled.fragmented:hover {
    opacity: 1; }

.reveal:not(.has-vertical-slides) .controls .navigate-left {
  bottom: 1.4em;
  right: 5.5em; }

.reveal:not(.has-vertical-slides) .controls .navigate-right {
  bottom: 1.4em;
  right: 0.5em; }

.reveal:not(.has-horizontal-slides) .controls .navigate-up {
  right: 1.4em;
  bottom: 5em; }

.reveal:not(.has-horizontal-slides) .controls .navigate-down {
  right: 1.4em;
  bottom: 0.5em; }

.reveal.has-dark-background .controls {
  color: #fff; }

.reveal.has-light-background .controls {
  color: #000; }

.reveal.no-hover .controls .controls-arrow:hover:before,
.reveal.no-hover .controls .controls-arrow:active:before {
  -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(45deg);
          transform: translateX(0.5em) translateY(1.55em) rotate(45deg); }

.reveal.no-hover .controls .controls-arrow:hover:after,
.reveal.no-hover .controls .controls-arrow:active:after {
  -webkit-transform: translateX(0.5em) translateY(1.55em) rotate(-45deg);
          transform: translateX(0.5em) translateY(1.55em) rotate(-45deg); }

@media screen and (min-width: 500px) {
  .reveal .controls[data-controls-layout="edges"] {
    top: 0;
    right: 0;
    bottom: 0;
    left: 0; }
  .reveal .controls[data-controls-layout="edges"] .navigate-left,
  .reveal .controls[data-controls-layout="edges"] .navigate-right,
  .reveal .controls[data-controls-layout="edges"] .navigate-up,
  .reveal .controls[data-controls-layout="edges"] .navigate-down {
    bottom: auto;
    right: auto; }
  .reveal .controls[data-controls-layout="edges"] .navigate-left {
    top: 50%;
    left: 8px;
    margin-top: -1.8em; }
  .reveal .controls[data-controls-layout="edges"] .navigate-right {
    top: 50%;
    right: 8px;
    margin-top: -1.8em; }
  .reveal .controls[data-controls-layout="edges"] .navigate-up {
    top: 8px;
    left: 50%;
    margin-left: -1.8em; }
  .reveal .controls[data-controls-layout="edges"] .navigate-down {
    bottom: 8px;
    left: 50%;
    margin-left: -1.8em; } }

/*********************************************
 * PROGRESS BAR
 *********************************************/
.reveal .progress {
  position: absolute;
  display: none;
  height: 3px;
  width: 100%;
  bottom: 0;
  left: 0;
  z-index: 10;
  background-color: rgba(0, 0, 0, 0.2);
  color: #fff; }

.reveal .progress:after {
  content: '';
  display: block;
  position: absolute;
  height: 10px;
  width: 100%;
  top: -10px; }

.reveal .progress span {
  display: block;
  height: 100%;
  width: 0px;
  background-color: currentColor;
  transition: width 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985); }

/*********************************************
 * SLIDE NUMBER
 *********************************************/
.reveal .slide-number {
  position: fixed;
  display: block;
  right: 8px;
  bottom: 8px;
  z-index: 31;
  font-family: Helvetica, sans-serif;
  font-size: 12px;
  line-height: 1;
  color: #fff;
  background-color: rgba(0, 0, 0, 0.4);
  padding: 5px; }

.reveal .slide-number-delimiter {
  margin: 0 3px; }

/*********************************************
 * SLIDES
 *********************************************/
.reveal {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  -ms-touch-action: none;
      touch-action: none; }

@media only screen and (orientation: landscape) {
  .reveal.ua-iphone {
    position: fixed; } }

.reveal .slides {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  pointer-events: none;
  overflow: visible;
  z-index: 1;
  text-align: center;
  -webkit-perspective: 600px;
          perspective: 600px;
  -webkit-perspective-origin: 50% 40%;
          perspective-origin: 50% 40%; }

.reveal .slides > section {
  -ms-perspective: 600px; }

.reveal .slides > section,
.reveal .slides > section > section {
  display: none;
  position: absolute;
  width: 100%;
  padding: 20px 0px;
  pointer-events: auto;
  z-index: 10;
  -webkit-transform-style: flat;
          transform-style: flat;
  transition: -webkit-transform-origin 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985), -webkit-transform 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985), visibility 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985), opacity 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985);
  transition: transform-origin 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985), transform 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985), visibility 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985), opacity 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985); }

/* Global transition speed settings */
.reveal[data-transition-speed="fast"] .slides section {
  transition-duration: 400ms; }

.reveal[data-transition-speed="slow"] .slides section {
  transition-duration: 1200ms; }

/* Slide-specific transition speed overrides */
.reveal .slides section[data-transition-speed="fast"] {
  transition-duration: 400ms; }

.reveal .slides section[data-transition-speed="slow"] {
  transition-duration: 1200ms; }

.reveal .slides > section.stack {
  padding-top: 0;
  padding-bottom: 0; }

.reveal .slides > section.present,
.reveal .slides > section > section.present {
  display: block;
  z-index: 11;
  opacity: 1; }

.reveal .slides > section:empty,
.reveal .slides > section > section:empty,
.reveal .slides > section[data-background-interactive],
.reveal .slides > section > section[data-background-interactive] {
  pointer-events: none; }

.reveal.center,
.reveal.center .slides,
.reveal.center .slides section {
  min-height: 0 !important; }

/* Don't allow interaction with invisible slides */
.reveal .slides > section.future,
.reveal .slides > section > section.future,
.reveal .slides > section.past,
.reveal .slides > section > section.past {
  pointer-events: none; }

.reveal.overview .slides > section,
.reveal.overview .slides > section > section {
  pointer-events: auto; }

.reveal .slides > section.past,
.reveal .slides > section.future,
.reveal .slides > section > section.past,
.reveal .slides > section > section.future {
  opacity: 0; }

/*********************************************
 * Mixins for readability of transitions
 *********************************************/
/*********************************************
 * SLIDE TRANSITION
 * Aliased 'linear' for backwards compatibility
 *********************************************/
.reveal.slide section {
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden; }

.reveal .slides > section[data-transition=slide].past,
.reveal .slides > section[data-transition~=slide-out].past,
.reveal.slide .slides > section:not([data-transition]).past {
  -webkit-transform: translate(-150%, 0);
          transform: translate(-150%, 0); }

.reveal .slides > section[data-transition=slide].future,
.reveal .slides > section[data-transition~=slide-in].future,
.reveal.slide .slides > section:not([data-transition]).future {
  -webkit-transform: translate(150%, 0);
          transform: translate(150%, 0); }

.reveal .slides > section > section[data-transition=slide].past,
.reveal .slides > section > section[data-transition~=slide-out].past,
.reveal.slide .slides > section > section:not([data-transition]).past {
  -webkit-transform: translate(0, -150%);
          transform: translate(0, -150%); }

.reveal .slides > section > section[data-transition=slide].future,
.reveal .slides > section > section[data-transition~=slide-in].future,
.reveal.slide .slides > section > section:not([data-transition]).future {
  -webkit-transform: translate(0, 150%);
          transform: translate(0, 150%); }

.reveal.linear section {
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden; }

.reveal .slides > section[data-transition=linear].past,
.reveal .slides > section[data-transition~=linear-out].past,
.reveal.linear .slides > section:not([data-transition]).past {
  -webkit-transform: translate(-150%, 0);
          transform: translate(-150%, 0); }

.reveal .slides > section[data-transition=linear].future,
.reveal .slides > section[data-transition~=linear-in].future,
.reveal.linear .slides > section:not([data-transition]).future {
  -webkit-transform: translate(150%, 0);
          transform: translate(150%, 0); }

.reveal .slides > section > section[data-transition=linear].past,
.reveal .slides > section > section[data-transition~=linear-out].past,
.reveal.linear .slides > section > section:not([data-transition]).past {
  -webkit-transform: translate(0, -150%);
          transform: translate(0, -150%); }

.reveal .slides > section > section[data-transition=linear].future,
.reveal .slides > section > section[data-transition~=linear-in].future,
.reveal.linear .slides > section > section:not([data-transition]).future {
  -webkit-transform: translate(0, 150%);
          transform: translate(0, 150%); }

/*********************************************
 * CONVEX TRANSITION
 * Aliased 'default' for backwards compatibility
 *********************************************/
.reveal .slides section[data-transition=default].stack,
.reveal.default .slides section.stack {
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d; }

.reveal .slides > section[data-transition=default].past,
.reveal .slides > section[data-transition~=default-out].past,
.reveal.default .slides > section:not([data-transition]).past {
  -webkit-transform: translate3d(-100%, 0, 0) rotateY(-90deg) translate3d(-100%, 0, 0);
          transform: translate3d(-100%, 0, 0) rotateY(-90deg) translate3d(-100%, 0, 0); }

.reveal .slides > section[data-transition=default].future,
.reveal .slides > section[data-transition~=default-in].future,
.reveal.default .slides > section:not([data-transition]).future {
  -webkit-transform: translate3d(100%, 0, 0) rotateY(90deg) translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0) rotateY(90deg) translate3d(100%, 0, 0); }

.reveal .slides > section > section[data-transition=default].past,
.reveal .slides > section > section[data-transition~=default-out].past,
.reveal.default .slides > section > section:not([data-transition]).past {
  -webkit-transform: translate3d(0, -300px, 0) rotateX(70deg) translate3d(0, -300px, 0);
          transform: translate3d(0, -300px, 0) rotateX(70deg) translate3d(0, -300px, 0); }

.reveal .slides > section > section[data-transition=default].future,
.reveal .slides > section > section[data-transition~=default-in].future,
.reveal.default .slides > section > section:not([data-transition]).future {
  -webkit-transform: translate3d(0, 300px, 0) rotateX(-70deg) translate3d(0, 300px, 0);
          transform: translate3d(0, 300px, 0) rotateX(-70deg) translate3d(0, 300px, 0); }

.reveal .slides section[data-transition=convex].stack,
.reveal.convex .slides section.stack {
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d; }

.reveal .slides > section[data-transition=convex].past,
.reveal .slides > section[data-transition~=convex-out].past,
.reveal.convex .slides > section:not([data-transition]).past {
  -webkit-transform: translate3d(-100%, 0, 0) rotateY(-90deg) translate3d(-100%, 0, 0);
          transform: translate3d(-100%, 0, 0) rotateY(-90deg) translate3d(-100%, 0, 0); }

.reveal .slides > section[data-transition=convex].future,
.reveal .slides > section[data-transition~=convex-in].future,
.reveal.convex .slides > section:not([data-transition]).future {
  -webkit-transform: translate3d(100%, 0, 0) rotateY(90deg) translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0) rotateY(90deg) translate3d(100%, 0, 0); }

.reveal .slides > section > section[data-transition=convex].past,
.reveal .slides > section > section[data-transition~=convex-out].past,
.reveal.convex .slides > section > section:not([data-transition]).past {
  -webkit-transform: translate3d(0, -300px, 0) rotateX(70deg) translate3d(0, -300px, 0);
          transform: translate3d(0, -300px, 0) rotateX(70deg) translate3d(0, -300px, 0); }

.reveal .slides > section > section[data-transition=convex].future,
.reveal .slides > section > section[data-transition~=convex-in].future,
.reveal.convex .slides > section > section:not([data-transition]).future {
  -webkit-transform: translate3d(0, 300px, 0) rotateX(-70deg) translate3d(0, 300px, 0);
          transform: translate3d(0, 300px, 0) rotateX(-70deg) translate3d(0, 300px, 0); }

/*********************************************
 * CONCAVE TRANSITION
 *********************************************/
.reveal .slides section[data-transition=concave].stack,
.reveal.concave .slides section.stack {
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d; }

.reveal .slides > section[data-transition=concave].past,
.reveal .slides > section[data-transition~=concave-out].past,
.reveal.concave .slides > section:not([data-transition]).past {
  -webkit-transform: translate3d(-100%, 0, 0) rotateY(90deg) translate3d(-100%, 0, 0);
          transform: translate3d(-100%, 0, 0) rotateY(90deg) translate3d(-100%, 0, 0); }

.reveal .slides > section[data-transition=concave].future,
.reveal .slides > section[data-transition~=concave-in].future,
.reveal.concave .slides > section:not([data-transition]).future {
  -webkit-transform: translate3d(100%, 0, 0) rotateY(-90deg) translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0) rotateY(-90deg) translate3d(100%, 0, 0); }

.reveal .slides > section > section[data-transition=concave].past,
.reveal .slides > section > section[data-transition~=concave-out].past,
.reveal.concave .slides > section > section:not([data-transition]).past {
  -webkit-transform: translate3d(0, -80%, 0) rotateX(-70deg) translate3d(0, -80%, 0);
          transform: translate3d(0, -80%, 0) rotateX(-70deg) translate3d(0, -80%, 0); }

.reveal .slides > section > section[data-transition=concave].future,
.reveal .slides > section > section[data-transition~=concave-in].future,
.reveal.concave .slides > section > section:not([data-transition]).future {
  -webkit-transform: translate3d(0, 80%, 0) rotateX(70deg) translate3d(0, 80%, 0);
          transform: translate3d(0, 80%, 0) rotateX(70deg) translate3d(0, 80%, 0); }

/*********************************************
 * ZOOM TRANSITION
 *********************************************/
.reveal .slides section[data-transition=zoom],
.reveal.zoom .slides section:not([data-transition]) {
  transition-timing-function: ease; }

.reveal .slides > section[data-transition=zoom].past,
.reveal .slides > section[data-transition~=zoom-out].past,
.reveal.zoom .slides > section:not([data-transition]).past {
  visibility: hidden;
  -webkit-transform: scale(16);
          transform: scale(16); }

.reveal .slides > section[data-transition=zoom].future,
.reveal .slides > section[data-transition~=zoom-in].future,
.reveal.zoom .slides > section:not([data-transition]).future {
  visibility: hidden;
  -webkit-transform: scale(0.2);
          transform: scale(0.2); }

.reveal .slides > section > section[data-transition=zoom].past,
.reveal .slides > section > section[data-transition~=zoom-out].past,
.reveal.zoom .slides > section > section:not([data-transition]).past {
  -webkit-transform: translate(0, -150%);
          transform: translate(0, -150%); }

.reveal .slides > section > section[data-transition=zoom].future,
.reveal .slides > section > section[data-transition~=zoom-in].future,
.reveal.zoom .slides > section > section:not([data-transition]).future {
  -webkit-transform: translate(0, 150%);
          transform: translate(0, 150%); }

/*********************************************
 * CUBE TRANSITION
 *
 * WARNING:
 * this is deprecated and will be removed in a
 * future version.
 *********************************************/
.reveal.cube .slides {
  -webkit-perspective: 1300px;
          perspective: 1300px; }

.reveal.cube .slides section {
  padding: 30px;
  min-height: 700px;
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden;
  box-sizing: border-box;
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d; }

.reveal.center.cube .slides section {
  min-height: 0; }

.reveal.cube .slides section:not(.stack):before {
  content: '';
  position: absolute;
  display: block;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
  -webkit-transform: translateZ(-20px);
          transform: translateZ(-20px); }

.reveal.cube .slides section:not(.stack):after {
  content: '';
  position: absolute;
  display: block;
  width: 90%;
  height: 30px;
  left: 5%;
  bottom: 0;
  background: none;
  z-index: 1;
  border-radius: 4px;
  box-shadow: 0px 95px 25px rgba(0, 0, 0, 0.2);
  -webkit-transform: translateZ(-90px) rotateX(65deg);
          transform: translateZ(-90px) rotateX(65deg); }

.reveal.cube .slides > section.stack {
  padding: 0;
  background: none; }

.reveal.cube .slides > section.past {
  -webkit-transform-origin: 100% 0%;
          transform-origin: 100% 0%;
  -webkit-transform: translate3d(-100%, 0, 0) rotateY(-90deg);
          transform: translate3d(-100%, 0, 0) rotateY(-90deg); }

.reveal.cube .slides > section.future {
  -webkit-transform-origin: 0% 0%;
          transform-origin: 0% 0%;
  -webkit-transform: translate3d(100%, 0, 0) rotateY(90deg);
          transform: translate3d(100%, 0, 0) rotateY(90deg); }

.reveal.cube .slides > section > section.past {
  -webkit-transform-origin: 0% 100%;
          transform-origin: 0% 100%;
  -webkit-transform: translate3d(0, -100%, 0) rotateX(90deg);
          transform: translate3d(0, -100%, 0) rotateX(90deg); }

.reveal.cube .slides > section > section.future {
  -webkit-transform-origin: 0% 0%;
          transform-origin: 0% 0%;
  -webkit-transform: translate3d(0, 100%, 0) rotateX(-90deg);
          transform: translate3d(0, 100%, 0) rotateX(-90deg); }

/*********************************************
 * PAGE TRANSITION
 *
 * WARNING:
 * this is deprecated and will be removed in a
 * future version.
 *********************************************/
.reveal.page .slides {
  -webkit-perspective-origin: 0% 50%;
          perspective-origin: 0% 50%;
  -webkit-perspective: 3000px;
          perspective: 3000px; }

.reveal.page .slides section {
  padding: 30px;
  min-height: 700px;
  box-sizing: border-box;
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d; }

.reveal.page .slides section.past {
  z-index: 12; }

.reveal.page .slides section:not(.stack):before {
  content: '';
  position: absolute;
  display: block;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  background: rgba(0, 0, 0, 0.1);
  -webkit-transform: translateZ(-20px);
          transform: translateZ(-20px); }

.reveal.page .slides section:not(.stack):after {
  content: '';
  position: absolute;
  display: block;
  width: 90%;
  height: 30px;
  left: 5%;
  bottom: 0;
  background: none;
  z-index: 1;
  border-radius: 4px;
  box-shadow: 0px 95px 25px rgba(0, 0, 0, 0.2);
  -webkit-transform: translateZ(-90px) rotateX(65deg); }

.reveal.page .slides > section.stack {
  padding: 0;
  background: none; }

.reveal.page .slides > section.past {
  -webkit-transform-origin: 0% 0%;
          transform-origin: 0% 0%;
  -webkit-transform: translate3d(-40%, 0, 0) rotateY(-80deg);
          transform: translate3d(-40%, 0, 0) rotateY(-80deg); }

.reveal.page .slides > section.future {
  -webkit-transform-origin: 100% 0%;
          transform-origin: 100% 0%;
  -webkit-transform: translate3d(0, 0, 0);
          transform: translate3d(0, 0, 0); }

.reveal.page .slides > section > section.past {
  -webkit-transform-origin: 0% 0%;
          transform-origin: 0% 0%;
  -webkit-transform: translate3d(0, -40%, 0) rotateX(80deg);
          transform: translate3d(0, -40%, 0) rotateX(80deg); }

.reveal.page .slides > section > section.future {
  -webkit-transform-origin: 0% 100%;
          transform-origin: 0% 100%;
  -webkit-transform: translate3d(0, 0, 0);
          transform: translate3d(0, 0, 0); }

/*********************************************
 * FADE TRANSITION
 *********************************************/
.reveal .slides section[data-transition=fade],
.reveal.fade .slides section:not([data-transition]),
.reveal.fade .slides > section > section:not([data-transition]) {
  -webkit-transform: none;
          transform: none;
  transition: opacity 0.5s; }

.reveal.fade.overview .slides section,
.reveal.fade.overview .slides > section > section {
  transition: none; }

/*********************************************
 * NO TRANSITION
 *********************************************/
.reveal .slides section[data-transition=none],
.reveal.none .slides section:not([data-transition]) {
  -webkit-transform: none;
          transform: none;
  transition: none; }

/*********************************************
 * PAUSED MODE
 *********************************************/
.reveal .pause-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: black;
  visibility: hidden;
  opacity: 0;
  z-index: 100;
  transition: all 1s ease; }

.reveal.paused .pause-overlay {
  visibility: visible;
  opacity: 1; }

/*********************************************
 * FALLBACK
 *********************************************/
.no-transforms {
  overflow-y: auto; }

.no-transforms .reveal .slides {
  position: relative;
  width: 80%;
  height: auto !important;
  top: 0;
  left: 50%;
  margin: 0;
  text-align: center; }

.no-transforms .reveal .controls,
.no-transforms .reveal .progress {
  display: none !important; }

.no-transforms .reveal .slides section {
  display: block !important;
  opacity: 1 !important;
  position: relative !important;
  height: auto;
  min-height: 0;
  top: 0;
  left: -50%;
  margin: 70px 0;
  -webkit-transform: none;
          transform: none; }

.no-transforms .reveal .slides section section {
  left: 0; }

.reveal .no-transition,
.reveal .no-transition * {
  transition: none !important; }

/*********************************************
 * PER-SLIDE BACKGROUNDS
 *********************************************/
.reveal .backgrounds {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  -webkit-perspective: 600px;
          perspective: 600px; }

.reveal .slide-background {
  display: none;
  position: absolute;
  width: 100%;
  height: 100%;
  opacity: 0;
  visibility: hidden;
  overflow: hidden;
  background-color: transparent;
  background-position: 50% 50%;
  background-repeat: no-repeat;
  background-size: cover;
  transition: all 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985); }

.reveal .slide-background.stack {
  display: block; }

.reveal .slide-background.present {
  opacity: 1;
  visibility: visible;
  z-index: 2; }

.print-pdf .reveal .slide-background {
  opacity: 1 !important;
  visibility: visible !important; }

/* Video backgrounds */
.reveal .slide-background video {
  position: absolute;
  width: 100%;
  height: 100%;
  max-width: none;
  max-height: none;
  top: 0;
  left: 0;
  -o-object-fit: cover;
     object-fit: cover; }

.reveal .slide-background[data-background-size="contain"] video {
  -o-object-fit: contain;
     object-fit: contain; }

/* Immediate transition style */
.reveal[data-background-transition=none] > .backgrounds .slide-background,
.reveal > .backgrounds .slide-background[data-background-transition=none] {
  transition: none; }

/* Slide */
.reveal[data-background-transition=slide] > .backgrounds .slide-background,
.reveal > .backgrounds .slide-background[data-background-transition=slide] {
  opacity: 1;
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden; }

.reveal[data-background-transition=slide] > .backgrounds .slide-background.past,
.reveal > .backgrounds .slide-background.past[data-background-transition=slide] {
  -webkit-transform: translate(-100%, 0);
          transform: translate(-100%, 0); }

.reveal[data-background-transition=slide] > .backgrounds .slide-background.future,
.reveal > .backgrounds .slide-background.future[data-background-transition=slide] {
  -webkit-transform: translate(100%, 0);
          transform: translate(100%, 0); }

.reveal[data-background-transition=slide] > .backgrounds .slide-background > .slide-background.past,
.reveal > .backgrounds .slide-background > .slide-background.past[data-background-transition=slide] {
  -webkit-transform: translate(0, -100%);
          transform: translate(0, -100%); }

.reveal[data-background-transition=slide] > .backgrounds .slide-background > .slide-background.future,
.reveal > .backgrounds .slide-background > .slide-background.future[data-background-transition=slide] {
  -webkit-transform: translate(0, 100%);
          transform: translate(0, 100%); }

/* Convex */
.reveal[data-background-transition=convex] > .backgrounds .slide-background.past,
.reveal > .backgrounds .slide-background.past[data-background-transition=convex] {
  opacity: 0;
  -webkit-transform: translate3d(-100%, 0, 0) rotateY(-90deg) translate3d(-100%, 0, 0);
          transform: translate3d(-100%, 0, 0) rotateY(-90deg) translate3d(-100%, 0, 0); }

.reveal[data-background-transition=convex] > .backgrounds .slide-background.future,
.reveal > .backgrounds .slide-background.future[data-background-transition=convex] {
  opacity: 0;
  -webkit-transform: translate3d(100%, 0, 0) rotateY(90deg) translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0) rotateY(90deg) translate3d(100%, 0, 0); }

.reveal[data-background-transition=convex] > .backgrounds .slide-background > .slide-background.past,
.reveal > .backgrounds .slide-background > .slide-background.past[data-background-transition=convex] {
  opacity: 0;
  -webkit-transform: translate3d(0, -100%, 0) rotateX(90deg) translate3d(0, -100%, 0);
          transform: translate3d(0, -100%, 0) rotateX(90deg) translate3d(0, -100%, 0); }

.reveal[data-background-transition=convex] > .backgrounds .slide-background > .slide-background.future,
.reveal > .backgrounds .slide-background > .slide-background.future[data-background-transition=convex] {
  opacity: 0;
  -webkit-transform: translate3d(0, 100%, 0) rotateX(-90deg) translate3d(0, 100%, 0);
          transform: translate3d(0, 100%, 0) rotateX(-90deg) translate3d(0, 100%, 0); }

/* Concave */
.reveal[data-background-transition=concave] > .backgrounds .slide-background.past,
.reveal > .backgrounds .slide-background.past[data-background-transition=concave] {
  opacity: 0;
  -webkit-transform: translate3d(-100%, 0, 0) rotateY(90deg) translate3d(-100%, 0, 0);
          transform: translate3d(-100%, 0, 0) rotateY(90deg) translate3d(-100%, 0, 0); }

.reveal[data-background-transition=concave] > .backgrounds .slide-background.future,
.reveal > .backgrounds .slide-background.future[data-background-transition=concave] {
  opacity: 0;
  -webkit-transform: translate3d(100%, 0, 0) rotateY(-90deg) translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0) rotateY(-90deg) translate3d(100%, 0, 0); }

.reveal[data-background-transition=concave] > .backgrounds .slide-background > .slide-background.past,
.reveal > .backgrounds .slide-background > .slide-background.past[data-background-transition=concave] {
  opacity: 0;
  -webkit-transform: translate3d(0, -100%, 0) rotateX(-90deg) translate3d(0, -100%, 0);
          transform: translate3d(0, -100%, 0) rotateX(-90deg) translate3d(0, -100%, 0); }

.reveal[data-background-transition=concave] > .backgrounds .slide-background > .slide-background.future,
.reveal > .backgrounds .slide-background > .slide-background.future[data-background-transition=concave] {
  opacity: 0;
  -webkit-transform: translate3d(0, 100%, 0) rotateX(90deg) translate3d(0, 100%, 0);
          transform: translate3d(0, 100%, 0) rotateX(90deg) translate3d(0, 100%, 0); }

/* Zoom */
.reveal[data-background-transition=zoom] > .backgrounds .slide-background,
.reveal > .backgrounds .slide-background[data-background-transition=zoom] {
  transition-timing-function: ease; }

.reveal[data-background-transition=zoom] > .backgrounds .slide-background.past,
.reveal > .backgrounds .slide-background.past[data-background-transition=zoom] {
  opacity: 0;
  visibility: hidden;
  -webkit-transform: scale(16);
          transform: scale(16); }

.reveal[data-background-transition=zoom] > .backgrounds .slide-background.future,
.reveal > .backgrounds .slide-background.future[data-background-transition=zoom] {
  opacity: 0;
  visibility: hidden;
  -webkit-transform: scale(0.2);
          transform: scale(0.2); }

.reveal[data-background-transition=zoom] > .backgrounds .slide-background > .slide-background.past,
.reveal > .backgrounds .slide-background > .slide-background.past[data-background-transition=zoom] {
  opacity: 0;
  visibility: hidden;
  -webkit-transform: scale(16);
          transform: scale(16); }

.reveal[data-background-transition=zoom] > .backgrounds .slide-background > .slide-background.future,
.reveal > .backgrounds .slide-background > .slide-background.future[data-background-transition=zoom] {
  opacity: 0;
  visibility: hidden;
  -webkit-transform: scale(0.2);
          transform: scale(0.2); }

/* Global transition speed settings */
.reveal[data-transition-speed="fast"] > .backgrounds .slide-background {
  transition-duration: 400ms; }

.reveal[data-transition-speed="slow"] > .backgrounds .slide-background {
  transition-duration: 1200ms; }

/*********************************************
 * OVERVIEW
 *********************************************/
.reveal.overview {
  -webkit-perspective-origin: 50% 50%;
          perspective-origin: 50% 50%;
  -webkit-perspective: 700px;
          perspective: 700px; }
  .reveal.overview .slides {
    -moz-transform-style: preserve-3d; }
  .reveal.overview .slides section {
    height: 100%;
    top: 0 !important;
    opacity: 1 !important;
    overflow: hidden;
    visibility: visible !important;
    cursor: pointer;
    box-sizing: border-box; }
  .reveal.overview .slides section:hover,
  .reveal.overview .slides section.present {
    outline: 10px solid rgba(150, 150, 150, 0.4);
    outline-offset: 10px; }
  .reveal.overview .slides section .fragment {
    opacity: 1;
    transition: none; }
  .reveal.overview .slides section:after,
  .reveal.overview .slides section:before {
    display: none !important; }
  .reveal.overview .slides > section.stack {
    padding: 0;
    top: 0 !important;
    background: none;
    outline: none;
    overflow: visible; }
  .reveal.overview .backgrounds {
    -webkit-perspective: inherit;
            perspective: inherit;
    -moz-transform-style: preserve-3d; }
  .reveal.overview .backgrounds .slide-background {
    opacity: 1;
    visibility: visible;
    outline: 10px solid rgba(150, 150, 150, 0.1);
    outline-offset: 10px; }
  .reveal.overview .backgrounds .slide-background.stack {
    overflow: visible; }

.reveal.overview .slides section,
.reveal.overview-deactivating .slides section {
  transition: none; }

.reveal.overview .backgrounds .slide-background,
.reveal.overview-deactivating .backgrounds .slide-background {
  transition: none; }

/*********************************************
 * RTL SUPPORT
 *********************************************/
.reveal.rtl .slides,
.reveal.rtl .slides h1,
.reveal.rtl .slides h2,
.reveal.rtl .slides h3,
.reveal.rtl .slides h4,
.reveal.rtl .slides h5,
.reveal.rtl .slides h6 {
  direction: rtl;
  font-family: sans-serif; }

.reveal.rtl pre,
.reveal.rtl code {
  direction: ltr; }

.reveal.rtl ol,
.reveal.rtl ul {
  text-align: right; }

.reveal.rtl .progress span {
  float: right; }

/*********************************************
 * PARALLAX BACKGROUND
 *********************************************/
.reveal.has-parallax-background .backgrounds {
  transition: all 0.8s ease; }

/* Global transition speed settings */
.reveal.has-parallax-background[data-transition-speed="fast"] .backgrounds {
  transition-duration: 400ms; }

.reveal.has-parallax-background[data-transition-speed="slow"] .backgrounds {
  transition-duration: 1200ms; }

/*********************************************
 * LINK PREVIEW OVERLAY
 *********************************************/
.reveal .overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  background: rgba(0, 0, 0, 0.9);
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease; }

.reveal .overlay.visible {
  opacity: 1;
  visibility: visible; }

.reveal .overlay .spinner {
  position: absolute;
  display: block;
  top: 50%;
  left: 50%;
  width: 32px;
  height: 32px;
  margin: -16px 0 0 -16px;
  z-index: 10;
  background-image: url(data:image/gif;base64,R0lGODlhIAAgAPMAAJmZmf%2F%2F%2F6%2Bvr8nJybW1tcDAwOjo6Nvb26ioqKOjo7Ozs%2FLy8vz8%2FAAAAAAAAAAAACH%2FC05FVFNDQVBFMi4wAwEAAAAh%2FhpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh%2BQQJCgAAACwAAAAAIAAgAAAE5xDISWlhperN52JLhSSdRgwVo1ICQZRUsiwHpTJT4iowNS8vyW2icCF6k8HMMBkCEDskxTBDAZwuAkkqIfxIQyhBQBFvAQSDITM5VDW6XNE4KagNh6Bgwe60smQUB3d4Rz1ZBApnFASDd0hihh12BkE9kjAJVlycXIg7CQIFA6SlnJ87paqbSKiKoqusnbMdmDC2tXQlkUhziYtyWTxIfy6BE8WJt5YJvpJivxNaGmLHT0VnOgSYf0dZXS7APdpB309RnHOG5gDqXGLDaC457D1zZ%2FV%2FnmOM82XiHRLYKhKP1oZmADdEAAAh%2BQQJCgAAACwAAAAAIAAgAAAE6hDISWlZpOrNp1lGNRSdRpDUolIGw5RUYhhHukqFu8DsrEyqnWThGvAmhVlteBvojpTDDBUEIFwMFBRAmBkSgOrBFZogCASwBDEY%2FCZSg7GSE0gSCjQBMVG023xWBhklAnoEdhQEfyNqMIcKjhRsjEdnezB%2BA4k8gTwJhFuiW4dokXiloUepBAp5qaKpp6%2BHo7aWW54wl7obvEe0kRuoplCGepwSx2jJvqHEmGt6whJpGpfJCHmOoNHKaHx61WiSR92E4lbFoq%2BB6QDtuetcaBPnW6%2BO7wDHpIiK9SaVK5GgV543tzjgGcghAgAh%2BQQJCgAAACwAAAAAIAAgAAAE7hDISSkxpOrN5zFHNWRdhSiVoVLHspRUMoyUakyEe8PTPCATW9A14E0UvuAKMNAZKYUZCiBMuBakSQKG8G2FzUWox2AUtAQFcBKlVQoLgQReZhQlCIJesQXI5B0CBnUMOxMCenoCfTCEWBsJColTMANldx15BGs8B5wlCZ9Po6OJkwmRpnqkqnuSrayqfKmqpLajoiW5HJq7FL1Gr2mMMcKUMIiJgIemy7xZtJsTmsM4xHiKv5KMCXqfyUCJEonXPN2rAOIAmsfB3uPoAK%2B%2BG%2Bw48edZPK%2BM6hLJpQg484enXIdQFSS1u6UhksENEQAAIfkECQoAAAAsAAAAACAAIAAABOcQyEmpGKLqzWcZRVUQnZYg1aBSh2GUVEIQ2aQOE%2BG%2BcD4ntpWkZQj1JIiZIogDFFyHI0UxQwFugMSOFIPJftfVAEoZLBbcLEFhlQiqGp1Vd140AUklUN3eCA51C1EWMzMCezCBBmkxVIVHBWd3HHl9JQOIJSdSnJ0TDKChCwUJjoWMPaGqDKannasMo6WnM562R5YluZRwur0wpgqZE7NKUm%2BFNRPIhjBJxKZteWuIBMN4zRMIVIhffcgojwCF117i4nlLnY5ztRLsnOk%2BaV%2BoJY7V7m76PdkS4trKcdg0Zc0tTcKkRAAAIfkECQoAAAAsAAAAACAAIAAABO4QyEkpKqjqzScpRaVkXZWQEximw1BSCUEIlDohrft6cpKCk5xid5MNJTaAIkekKGQkWyKHkvhKsR7ARmitkAYDYRIbUQRQjWBwJRzChi9CRlBcY1UN4g0%2FVNB0AlcvcAYHRyZPdEQFYV8ccwR5HWxEJ02YmRMLnJ1xCYp0Y5idpQuhopmmC2KgojKasUQDk5BNAwwMOh2RtRq5uQuPZKGIJQIGwAwGf6I0JXMpC8C7kXWDBINFMxS4DKMAWVWAGYsAdNqW5uaRxkSKJOZKaU3tPOBZ4DuK2LATgJhkPJMgTwKCdFjyPHEnKxFCDhEAACH5BAkKAAAALAAAAAAgACAAAATzEMhJaVKp6s2nIkolIJ2WkBShpkVRWqqQrhLSEu9MZJKK9y1ZrqYK9WiClmvoUaF8gIQSNeF1Er4MNFn4SRSDARWroAIETg1iVwuHjYB1kYc1mwruwXKC9gmsJXliGxc%2BXiUCby9ydh1sOSdMkpMTBpaXBzsfhoc5l58Gm5yToAaZhaOUqjkDgCWNHAULCwOLaTmzswadEqggQwgHuQsHIoZCHQMMQgQGubVEcxOPFAcMDAYUA85eWARmfSRQCdcMe0zeP1AAygwLlJtPNAAL19DARdPzBOWSm1brJBi45soRAWQAAkrQIykShQ9wVhHCwCQCACH5BAkKAAAALAAAAAAgACAAAATrEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq%2BE71SRQeyqUToLA7VxF0JDyIQh%2FMVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiRMDjI0Fd30%2FiI2UA5GSS5UDj2l6NoqgOgN4gksEBgYFf0FDqKgHnyZ9OX8HrgYHdHpcHQULXAS2qKpENRg7eAMLC7kTBaixUYFkKAzWAAnLC7FLVxLWDBLKCwaKTULgEwbLA4hJtOkSBNqITT3xEgfLpBtzE%2FjiuL04RGEBgwWhShRgQExHBAAh%2BQQJCgAAACwAAAAAIAAgAAAE7xDISWlSqerNpyJKhWRdlSAVoVLCWk6JKlAqAavhO9UkUHsqlE6CwO1cRdCQ8iEIfzFVTzLdRAmZX3I2SfZiCqGk5dTESJeaOAlClzsJsqwiJwiqnFrb2nS9kmIcgEsjQydLiIlHehhpejaIjzh9eomSjZR%2BipslWIRLAgMDOR2DOqKogTB9pCUJBagDBXR6XB0EBkIIsaRsGGMMAxoDBgYHTKJiUYEGDAzHC9EACcUGkIgFzgwZ0QsSBcXHiQvOwgDdEwfFs0sDzt4S6BK4xYjkDOzn0unFeBzOBijIm1Dgmg5YFQwsCMjp1oJ8LyIAACH5BAkKAAAALAAAAAAgACAAAATwEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq%2BE71SRQeyqUToLA7VxF0JDyIQh%2FMVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiUd6GGl6NoiPOH16iZKNlH6KmyWFOggHhEEvAwwMA0N9GBsEC6amhnVcEwavDAazGwIDaH1ipaYLBUTCGgQDA8NdHz0FpqgTBwsLqAbWAAnIA4FWKdMLGdYGEgraigbT0OITBcg5QwPT4xLrROZL6AuQAPUS7bxLpoWidY0JtxLHKhwwMJBTHgPKdEQAACH5BAkKAAAALAAAAAAgACAAAATrEMhJaVKp6s2nIkqFZF2VIBWhUsJaTokqUCoBq%2BE71SRQeyqUToLA7VxF0JDyIQh%2FMVVPMt1ECZlfcjZJ9mIKoaTl1MRIl5o4CUKXOwmyrCInCKqcWtvadL2SYhyASyNDJ0uIiUd6GAULDJCRiXo1CpGXDJOUjY%2BYip9DhToJA4RBLwMLCwVDfRgbBAaqqoZ1XBMHswsHtxtFaH1iqaoGNgAIxRpbFAgfPQSqpbgGBqUD1wBXeCYp1AYZ19JJOYgH1KwA4UBvQwXUBxPqVD9L3sbp2BNk2xvvFPJd%2BMFCN6HAAIKgNggY0KtEBAAh%2BQQJCgAAACwAAAAAIAAgAAAE6BDISWlSqerNpyJKhWRdlSAVoVLCWk6JKlAqAavhO9UkUHsqlE6CwO1cRdCQ8iEIfzFVTzLdRAmZX3I2SfYIDMaAFdTESJeaEDAIMxYFqrOUaNW4E4ObYcCXaiBVEgULe0NJaxxtYksjh2NLkZISgDgJhHthkpU4mW6blRiYmZOlh4JWkDqILwUGBnE6TYEbCgevr0N1gH4At7gHiRpFaLNrrq8HNgAJA70AWxQIH1%2BvsYMDAzZQPC9VCNkDWUhGkuE5PxJNwiUK4UfLzOlD4WvzAHaoG9nxPi5d%2BjYUqfAhhykOFwJWiAAAIfkECQoAAAAsAAAAACAAIAAABPAQyElpUqnqzaciSoVkXVUMFaFSwlpOCcMYlErAavhOMnNLNo8KsZsMZItJEIDIFSkLGQoQTNhIsFehRww2CQLKF0tYGKYSg%2BygsZIuNqJksKgbfgIGepNo2cIUB3V1B3IvNiBYNQaDSTtfhhx0CwVPI0UJe0%2Bbm4g5VgcGoqOcnjmjqDSdnhgEoamcsZuXO1aWQy8KAwOAuTYYGwi7w5h%2BKr0SJ8MFihpNbx%2B4Erq7BYBuzsdiH1jCAzoSfl0rVirNbRXlBBlLX%2BBP0XJLAPGzTkAuAOqb0WT5AH7OcdCm5B8TgRwSRKIHQtaLCwg1RAAAOwAAAAAAAAAAAA%3D%3D);
  visibility: visible;
  opacity: 0.6;
  transition: all 0.3s ease; }

.reveal .overlay header {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 40px;
  z-index: 2;
  border-bottom: 1px solid #222; }

.reveal .overlay header a {
  display: inline-block;
  width: 40px;
  height: 40px;
  line-height: 36px;
  padding: 0 10px;
  float: right;
  opacity: 0.6;
  box-sizing: border-box; }

.reveal .overlay header a:hover {
  opacity: 1; }

.reveal .overlay header a .icon {
  display: inline-block;
  width: 20px;
  height: 20px;
  background-position: 50% 50%;
  background-size: 100%;
  background-repeat: no-repeat; }

.reveal .overlay header a.close .icon {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABkklEQVRYR8WX4VHDMAxG6wnoJrABZQPYBCaBTWAD2g1gE5gg6OOsXuxIlr40d81dfrSJ9V4c2VLK7spHuTJ/5wpM07QXuXc5X0opX2tEJcadjHuV80li/FgxTIEK/5QBCICBD6xEhSMGHgQPgBgLiYVAB1dpSqKDawxTohFw4JSEA3clzgIBPCURwE2JucBR7rhPJJv5OpJwDX+SfDjgx1wACQeJG1aChP9K/IMmdZ8DtESV1WyP3Bt4MwM6sj4NMxMYiqUWHQu4KYA/SYkIjOsm3BXYWMKFDwU2khjCQ4ELJUJ4SmClRArOCmSXGuKma0fYD5CbzHxFpCSGAhfAVSSUGDUk2BWZaff2g6GE15BsBQ9nwmpIGDiyHQddwNTMKkbZaf9fajXQca1EX44puJZUsnY0ObGmITE3GVLCbEhQUjGVt146j6oasWN+49Vph2w1pZ5EansNZqKBm1txbU57iRRcZ86RWMDdWtBJUHBHwoQPi1GV+JCbntmvok7iTX4/Up9mgyTc/FJYDTcndgH/AA5A/CHsyEkVAAAAAElFTkSuQmCC); }

.reveal .overlay header a.external .icon {
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAcElEQVRYR+2WSQoAIQwEzf8f7XiOMkUQxUPlGkM3hVmiQfQR9GYnH1SsAQlI4DiBqkCMoNb9y2e90IAEJPAcgdznU9+engMaeJ7Azh5Y1U67gAho4DqBqmB1buAf0MB1AlVBek83ZPkmJMGc1wAR+AAqod/B97TRpQAAAABJRU5ErkJggg==); }

.reveal .overlay .viewport {
  position: absolute;
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  top: 40px;
  right: 0;
  bottom: 0;
  left: 0; }

.reveal .overlay.overlay-preview .viewport iframe {
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  border: 0;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease; }

.reveal .overlay.overlay-preview.loaded .viewport iframe {
  opacity: 1;
  visibility: visible; }

.reveal .overlay.overlay-preview.loaded .viewport-inner {
  position: absolute;
  z-index: -1;
  left: 0;
  top: 45%;
  width: 100%;
  text-align: center;
  letter-spacing: normal; }

.reveal .overlay.overlay-preview .x-frame-error {
  opacity: 0;
  transition: opacity 0.3s ease 0.3s; }

.reveal .overlay.overlay-preview.loaded .x-frame-error {
  opacity: 1; }

.reveal .overlay.overlay-preview.loaded .spinner {
  opacity: 0;
  visibility: hidden;
  -webkit-transform: scale(0.2);
          transform: scale(0.2); }

.reveal .overlay.overlay-help .viewport {
  overflow: auto;
  color: #fff; }

.reveal .overlay.overlay-help .viewport .viewport-inner {
  width: 600px;
  margin: auto;
  padding: 20px 20px 80px 20px;
  text-align: center;
  letter-spacing: normal; }

.reveal .overlay.overlay-help .viewport .viewport-inner .title {
  font-size: 20px; }

.reveal .overlay.overlay-help .viewport .viewport-inner table {
  border: 1px solid #fff;
  border-collapse: collapse;
  font-size: 16px; }

.reveal .overlay.overlay-help .viewport .viewport-inner table th,
.reveal .overlay.overlay-help .viewport .viewport-inner table td {
  width: 200px;
  padding: 14px;
  border: 1px solid #fff;
  vertical-align: middle; }

.reveal .overlay.overlay-help .viewport .viewport-inner table th {
  padding-top: 20px;
  padding-bottom: 20px; }

/*********************************************
 * PLAYBACK COMPONENT
 *********************************************/
.reveal .playback {
  position: absolute;
  left: 15px;
  bottom: 20px;
  z-index: 30;
  cursor: pointer;
  transition: all 400ms ease;
  -webkit-tap-highlight-color: transparent; }

.reveal.overview .playback {
  opacity: 0;
  visibility: hidden; }

/*********************************************
 * ROLLING LINKS
 *********************************************/
.reveal .roll {
  display: inline-block;
  line-height: 1.2;
  overflow: hidden;
  vertical-align: top;
  -webkit-perspective: 400px;
          perspective: 400px;
  -webkit-perspective-origin: 50% 50%;
          perspective-origin: 50% 50%; }

.reveal .roll:hover {
  background: none;
  text-shadow: none; }

.reveal .roll span {
  display: block;
  position: relative;
  padding: 0 2px;
  pointer-events: none;
  transition: all 400ms ease;
  -webkit-transform-origin: 50% 0%;
          transform-origin: 50% 0%;
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden; }

.reveal .roll:hover span {
  background: rgba(0, 0, 0, 0.5);
  -webkit-transform: translate3d(0px, 0px, -45px) rotateX(90deg);
          transform: translate3d(0px, 0px, -45px) rotateX(90deg); }

.reveal .roll span:after {
  content: attr(data-title);
  display: block;
  position: absolute;
  left: 0;
  top: 0;
  padding: 0 2px;
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden;
  -webkit-transform-origin: 50% 0%;
          transform-origin: 50% 0%;
  -webkit-transform: translate3d(0px, 110%, 0px) rotateX(-90deg);
          transform: translate3d(0px, 110%, 0px) rotateX(-90deg); }

/*********************************************
 * SPEAKER NOTES
 *********************************************/
.reveal aside.notes {
  display: none; }

.reveal .speaker-notes {
  display: none;
  position: absolute;
  width: 25vw;
  height: 100%;
  top: 0;
  left: 100%;
  padding: 14px 18px 14px 18px;
  z-index: 1;
  font-size: 18px;
  line-height: 1.4;
  border: 1px solid rgba(0, 0, 0, 0.05);
  color: #222;
  background-color: #f5f5f5;
  overflow: auto;
  box-sizing: border-box;
  text-align: left;
  font-family: Helvetica, sans-serif;
  -webkit-overflow-scrolling: touch; }
  .reveal .speaker-notes .notes-placeholder {
    color: #ccc;
    font-style: italic; }
  .reveal .speaker-notes:focus {
    outline: none; }
  .reveal .speaker-notes:before {
    content: 'Speaker notes';
    display: block;
    margin-bottom: 10px;
    opacity: 0.5; }

.reveal.show-notes {
  max-width: 75vw;
  overflow: visible; }

.reveal.show-notes .speaker-notes {
  display: block; }

@media screen and (min-width: 1600px) {
  .reveal .speaker-notes {
    font-size: 20px; } }

@media screen and (max-width: 1024px) {
  .reveal.show-notes {
    border-left: 0;
    max-width: none;
    max-height: 70%;
    overflow: visible; }
  .reveal.show-notes .speaker-notes {
    top: 100%;
    left: 0;
    width: 100%;
    height: 42.8571428571%; } }

@media screen and (max-width: 600px) {
  .reveal.show-notes {
    max-height: 60%; }
  .reveal.show-notes .speaker-notes {
    top: 100%;
    height: 66.6666666667%; }
  .reveal .speaker-notes {
    font-size: 14px; } }

/*********************************************
 * ZOOM PLUGIN
 *********************************************/
.zoomed .reveal *,
.zoomed .reveal *:before,
.zoomed .reveal *:after {
  -webkit-backface-visibility: visible !important;
          backface-visibility: visible !important; }

.zoomed .reveal .progress,
.zoomed .reveal .controls {
  opacity: 0; }

.zoomed .reveal .roll span {
  background: none; }

.zoomed .reveal .roll span:after {
  visibility: hidden; }

</style>

<style type="text/css">
/**
 * Solarized Light theme for reveal.js.
 * Author: Achim Staebler
 */
@import url(../../lib/font/league-gothic/league-gothic.css);
@import url(https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic);
/**
 * Solarized colors by Ethan Schoonover
 */
html * {
  color-profile: sRGB;
  rendering-intent: auto; }

/*********************************************
 * GLOBAL STYLES
 *********************************************/
body {
  background: #fdf6e3;
  background-color: #fdf6e3; }

.reveal {
  font-family: "Lato", sans-serif;
  font-size: 40px;
  font-weight: normal;
  color: #657b83; }

::selection {
  color: #fff;
  background: #d33682;
  text-shadow: none; }

::-moz-selection {
  color: #fff;
  background: #d33682;
  text-shadow: none; }

.reveal .slides > section,
.reveal .slides > section > section {
  line-height: 1.3;
  font-weight: inherit; }

/*********************************************
 * HEADERS
 *********************************************/
.reveal h1,
.reveal h2,
.reveal h3,
.reveal h4,
.reveal h5,
.reveal h6 {
  margin: 0 0 20px 0;
  color: #586e75;
  font-family: "League Gothic", Impact, sans-serif;
  font-weight: normal;
  line-height: 1.2;
  letter-spacing: normal;
  text-transform: uppercase;
  text-shadow: none;
  word-wrap: break-word; }

.reveal h1 {
  font-size: 3.77em; }

.reveal h2 {
  font-size: 2.11em; }

.reveal h3 {
  font-size: 1.55em; }

.reveal h4 {
  font-size: 1em; }

.reveal h1 {
  text-shadow: none; }

/*********************************************
 * OTHER
 *********************************************/
.reveal p {
  margin: 20px 0;
  line-height: 1.3; }

/* Ensure certain elements are never larger than the slide itself */
.reveal img,
.reveal video,
.reveal iframe {
  max-width: 95%;
  max-height: 95%; }

.reveal strong,
.reveal b {
  font-weight: bold; }

.reveal em {
  font-style: italic; }

.reveal ol,
.reveal dl,
.reveal ul {
  display: inline-block;
  text-align: left;
  margin: 0 0 0 1em; }

.reveal ol {
  list-style-type: decimal; }

.reveal ul {
  list-style-type: disc; }

.reveal ul ul {
  list-style-type: square; }

.reveal ul ul ul {
  list-style-type: circle; }

.reveal ul ul,
.reveal ul ol,
.reveal ol ol,
.reveal ol ul {
  display: block;
  margin-left: 40px; }

.reveal dt {
  font-weight: bold; }

.reveal dd {
  margin-left: 40px; }

.reveal blockquote {
  display: block;
  position: relative;
  width: 70%;
  margin: 20px auto;
  padding: 5px;
  font-style: italic;
  background: rgba(255, 255, 255, 0.05);
  box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.2); }

.reveal blockquote p:first-child,
.reveal blockquote p:last-child {
  display: inline-block; }

.reveal q {
  font-style: italic; }

.reveal pre {
  display: block;
  position: relative;
  width: 90%;
  margin: 20px auto;
  text-align: left;
  font-size: 0.55em;
  font-family: monospace;
  line-height: 1.2em;
  word-wrap: break-word;
  box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.3); }

.reveal code {
  font-family: monospace;
  text-transform: none; }

.reveal pre code {
  display: block;
  padding: 5px;
  overflow: auto;
  max-height: 400px;
  word-wrap: normal; }

.reveal table {
  margin: auto;
  border-collapse: collapse;
  border-spacing: 0; }

.reveal table th {
  font-weight: bold; }

.reveal table th,
.reveal table td {
  text-align: left;
  padding: 0.2em 0.5em 0.2em 0.5em;
  border-bottom: 1px solid; }

.reveal table th[align="center"],
.reveal table td[align="center"] {
  text-align: center; }

.reveal table th[align="right"],
.reveal table td[align="right"] {
  text-align: right; }

.reveal table tbody tr:last-child th,
.reveal table tbody tr:last-child td {
  border-bottom: none; }

.reveal sup {
  vertical-align: super; }

.reveal sub {
  vertical-align: sub; }

.reveal small {
  display: inline-block;
  font-size: 0.6em;
  line-height: 1.2em;
  vertical-align: top; }

.reveal small * {
  vertical-align: top; }

/*********************************************
 * LINKS
 *********************************************/
.reveal a {
  color: #268bd2;
  text-decoration: none;
  -webkit-transition: color .15s ease;
  -moz-transition: color .15s ease;
  transition: color .15s ease; }

.reveal a:hover {
  color: #78b9e6;
  text-shadow: none;
  border: none; }

.reveal .roll span:after {
  color: #fff;
  background: #1a6091; }

/*********************************************
 * IMAGES
 *********************************************/
.reveal section img {
  margin: 15px 0px;
  background: rgba(255, 255, 255, 0.12);
  border: 4px solid #657b83;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.15); }

.reveal section img.plain {
  border: 0;
  box-shadow: none; }

.reveal a img {
  -webkit-transition: all .15s linear;
  -moz-transition: all .15s linear;
  transition: all .15s linear; }

.reveal a:hover img {
  background: rgba(255, 255, 255, 0.2);
  border-color: #268bd2;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.55); }

/*********************************************
 * NAVIGATION CONTROLS
 *********************************************/
.reveal .controls {
  color: #268bd2; }

/*********************************************
 * PROGRESS BAR
 *********************************************/
.reveal .progress {
  background: rgba(0, 0, 0, 0.2);
  color: #268bd2; }

.reveal .progress span {
  -webkit-transition: width 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985);
  -moz-transition: width 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985);
  transition: width 800ms cubic-bezier(0.26, 0.86, 0.44, 0.985); }

</style>

</head>
<body>
<div class="reveal">
<div class="slides">

<section>
<section id="slide-org94d68ed">
<h2 id="org94d68ed">ABCs of GenStage</h2>
<div class="outline-text-2" id="text-org94d68ed">
</div>
</section>
<section id="slide-org5877db6">
<h3 id="org5877db6">Wadsworth's constant</h3>
<ul>
<li>Aldric</li>
<li>Exeq</li>

</ul>
</section>
<section id="slide-org0b9a44c">
<h3 id="org0b9a44c">Learning objectives</h3>
<ul>
<li>Explain what GenStage is</li>
<li>Decide whether or not to use GenStage</li>
<li>Set up a GenStage pipeline</li>

</ul>
</section>
</section>
<section>
<section id="slide-orge98cd3b">
<h2 id="orge98cd3b">Mindset: "Flow of data"</h2>
<p>
And further: flow of data processing
</p>
</section>
</section>
<section>
<section id="slide-org8343f4f">
<h2 id="org8343f4f">The ol' <code>Stream</code></h2>
<p>
Literally, a stream of data
</p>
</section>
</section>
<section>
<section id="slide-org8281946">
<h2 id="org8281946">Distributing work with stdlib</h2>
<p>
<code>Task.async_stream/3</code> (and <code>/5</code>)
</p>
</section>
<section id="slide-org6ef2aac">
<h3 id="org6ef2aac">One pic == 1k words</h3>

<div class="figure">
<p><img src="data:image/png;base64,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
LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlv
biByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNv
bS9leGlmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MzYwPC9leGlmOlBp
eGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjM0MTwvZXhpZjpQ
aXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+Cjwv
eDp4bXBtZXRhPgpizmN5AABAAElEQVR4AezdBby8RfU/8Mf62y0G1hclBEVFOhQERAnpbukOQVEQ
pFM6JKRDSkJAQkkpCUmxEBAL7G5/9/+8R87X/S439u4+u/vs3pnXa+/efWLmzJmZz5w558yZ54yU
qcgpcyBzIHMgc6B2HHhu7SjKBGUOZA5kDmQOJA5kgM4dIXMgcyBzoKYcyABd04bJZGUOZA5kDmSA
zn0gcyBzIHOgphzIAF3ThslkZQ5kDmQOZIDOfSBzIHMgc6CmHMgAXdOGyWRlDmQOZA5kgM59IHMg
cyBzoKYcyABd04bJZGUOZA5kDmSAzn0gcyBzIHOgphzIAF3ThslkZQ5kDmQOZIDOfSBzIHMgc6Cm
HMgAXdOGyWRlDmQOZA5kgM59IHMgcyBzoKYceH5N6cpkNXDgZz/7WXHppZcW73nPe4qFF164eOEL
X9hwN/+bOVB/DvziF78oHnzwweKJJ54o/vrXvxZ/+ctfiqeffrr4z3/+Uzz3uc9N3y9+8YuLPffc
s3j1q19d/wr1iMLn5HjQPeJ0G8UA5TvuuCN16m9961vF2972tuLiiy8u3vCGN7SRW36lnxwQdv2h
hx4qfvrTn6ZJ9lWvelXxnOc8p58kTbpsoPq9732v+OUvf1mg/+9//3vxu9/9rvjTn/5U/OEPfyj+
7//+r3jpS1+afnvmz3/+cwJedffcj3/84/TuP//5z/RuvIMP3v1//+//FT/4wQ9SP580cUP6Qpag
x2jYQw89tPjJT35SrL322sX888+fOs8Yj1Z+GTDfdNNNxS233JI67N/+9rdCJ3/yySeL3/zmN8VM
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" />
</p>
</div>
</section>
<section id="slide-orge1fcc7f">
<h3 id="orge1fcc7f">Limitations</h3>
<ul>
<li>Stream</li>
<li>One function</li>

</ul>
</section>
<section id="slide-org4899cf2">
<h3 id="org4899cf2">An example</h3>
<p>
Use an external reverse geocoding service to get addresses from coordinates
</p>
</section>
</section>
<section>
<section id="slide-org0b90a36">
<h2 id="org0b90a36">How can we extend this idea?</h2>
<p>
We want to make it scalable!
</p>

<p>
The new old buzzword.
</p>
</section>
</section>
<section>
<section id="slide-org36e0cc8">
<h2 id="org36e0cc8">Pub/sub</h2>
<p>
Publish / subscribe
</p>
</section>
</section>
<section>
<section id="slide-org38cc7cf">
<h2 id="org38cc7cf">Setting the stage (rimshot)</h2>
<div class="outline-text-2" id="text-org38cc7cf">
</div>
</section>
<section id="slide-org8d426c5">
<h3 id="org8d426c5">Let me explain. No, there is too much. Let me sum up.</h3>

<div class="figure">
<p><img src="data:image/png;base64,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
LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlv
biByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNv
bS9leGlmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NTIxPC9leGlmOlBp
eGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI4NDwvZXhpZjpQ
aXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+Cjwv
eDp4bXBtZXRhPgqEnRsSAABAAElEQVR4Ae3dBbytRfU38EEaaZSOS3d3X2kQEAFpkJBSJJT6E0qJ
lCISgqCgAqKEdKfS3a10d0gj7/0O79z73MM+vfe5Z++95vM5Z+/9xDwzv1mz5rfWrJlntC+GpRQp
EAgEAoFAIBAIBAKBDgh8rcPv+BkIBAKBQCAQCAQCgUBGIEhCCEIgEAgEAoFAIBAI1EQgSEJNWOJg
IBAIBAKBQCAQCARJCBkIBAKBQCAQCAQCgZoIBEmoCUscDAQCgUAgEAgEAoEgCSEDgUAgEAgEAoFA
IFATgSAJNWGJg4FAIBAIBAKBQCAQJCFkIBAIBAKBQCAQCARqIhAkoSYscTAQCAQCgUAgEAgEgiSE
DAQCgUAgEAgEAoFATQSCJNSEJQ4GAoFAIBAIBAKBQJCEkIFAIBAIBAKBQCAQqIlAkISasMTBQCAQ
CAQCgUAgEAiSEDIQCAQCgUAgEAgEAjURCJJQE5Y4GAgEAoFAIBAIBAJBEkIGAoFAIBAIBAKBQKAm
AkESasISBwOBQCAQCAQCgUAgSELIQCAQCAQCgUAgEAjURCBIQk1Y4mAgEAgEAoFAIBAIBEkIGQgE
AoFAIBAIBAKBmggESagJSxwMBAKBQCAQCAQCgSAJIQOBQCAQCAQCgUAgUBOBIAk1YYmDgUAgEAgE
AoFAIBAkIWQgEAgEAoFAIBAIBGoiECShJixxMBAIBAKBQCAQCASCJIQMBAKBQCAQCAQCgUBNBIIk
1IQlDgYCgUAgEAgEAoFAkISQgUAgEAgEAoFAIBCoiUCQhJqwxMFAIBAIBAKBQCAQCJIQMhAIBAKB
QCAQCAQCNREIklATljgYCAQCgUAgEAgEAkESQgYCgUAgEAgEAoFAoCYCQRJqwhIHA4FAIBAIBAKB
QCBIQshAIBAIBAKBQCAQCNREIEhCTVjiYCAQCAQCgUAgEAgESQgZCAQCgUAgEAgEAoGaCARJqAlL
HAwEAoFAIBAIBAKBIAkhA4FAIBAIBAKBQCBQE4Exah5tooMPP/xwevTRR9P777+fxhlnnDT77LOn
ueaaK4055phNVIsoaiAQCAQCgUAgMPgQaGqScOmll6azzjor/etf/0pvvvlmGn/88dNSSy2V1l9/
/bTGGmvk36ONNtrgQz1KFAgEAoFAIBAINAECTUsSbr755rTvvvumBx54IE0xxRRpnXXWSY899li6
8sor03333ZdJwxZbbJG+/vWvN0EzRBEDgUAgEAgEAoHBh0DTkoTTTjstPf7444mnYPvtt0+77rpr
uuWWW9Lll1+e/va3v6VDDz00TT311Gm11VZLY4899uBDPkoUCFQQuOGGG9Irr7ySZpllljTvvPPG
dFkFm/gaCAQCow6BpiUJn376afriiy/SIosskknChBNOmFZdddW05JJLZlJw8sknp9/85jdp8cUX
T1NOOeWoQzieHAh0g8AjjzySDj744OSTPK+11lpp7bXXTt/4xjfS174WscXdwBenA4FAoIEINK0G
GjJkSBpjjDHSuuuuO9KUArKw0047pbnnnjvdfffd2bvw8ccfNxDCyDoQ6B8CCO1tt92WXn311ewJ
22uvvdLxxx+fnnvuufS///2vf5nH3YFAIBAI9AOBpiUJ4hCQBFMJHYMTp5122myJscL+8pe/pPfe
e68fEMWtgUBjEbjiiivSBx98kJZddtm03XbbZdL761//OhOFkN3GYh+5BwKBQNcINC1JsJIBOaBc
TTt0TFY4TDTRROn+++9Pn3zyScfT8TsQGDQIfP7551mGN9xww3T44Yenn/70p2ncccdNv/vd77In
LOR30DRVFCQQaDsEmpYkfPOb30yjjz56mnTSSWvO25qOMPVAwdYiEW3X0lHhQYuA2AOyjPjyfu2y
yy5pxhlnTB9++GF4wgZtq0XBAoH2QKBpScIEE0yQFSqLy5JHCrWaylyu82U6wjX/+Mc/0j//+c8U
cQpVtOL7qESgEF4E4fnnn08XXHBB9pCR29deey3iEkZl48SzA4E2R6BpVzeUdrvuuuvS3//+9zR0
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
DdJRRx2VeAd4Jr71rW+l008/PU011VR50L3sssvygLzwwgvnY6OPPnp+lvn+IUOGpDXWWCM//+tf
//rwx7/55pvZOmfRy8c90pNPPpluvPHG/JyJJpoo8RJ0HMhdN8EEE2Qy8Prrr6d99903k5Gllloq
exFMKyy77LIjeQeuvPLK7EEYOnRoOvjgg/M59USglFPiKTj++OMzSdhll13Svffemw4//PB00003
5fxd87WvRfw2HCIFArUQCJJQC5U4FggMEgSuuuqqtMcee+SBXiDeZpttloP3ag2ypcjFlf7vf/87
D5gGWoP2I488kt33t9xyS7ae//Wvf+WBW168Ciz3jTfeOFvn+++/fyYJLHREw+C+ySabJHka/LfZ
Zps0++yzjzTAGrQNyFtttVXaaKONhhMBlvuee+6ZXnvttTTFFFPkwb5W+WeZZZZcLtMEAhSREc//
yU9+kquGmFTvQ5qQgjnmmCNdc801Sb2nmWaatN122w33bpiSMB1hKgOpOuaYY9I999yTVlhhhTxl
8u6772YPSldTEwXX+AwE2hGBoNDt2OpR56ZB4LDDDkvPP/98niLgTeABqA6UtSpy2mmnpd133z17
BHbcccckj0MPPTQtssgi2RvA0uZd4NaXEA9z+EcffXS64YYb0plnnpnd/TwA1w+LP+BpkDbffPO0
6KKLJtMCVhsIJKwm3gfTEeIHTBGUNPPMM6f55psvW+68DaY+OksICO/EQQcdlMvsee6RH6LywAMP
5N/yQFiQBN4QRAIBOOWUU7J3oeSPlMjT3wknnJCnL5ZeeulMGN544438rG233XY4qSj3xWcgEAh8
iUB4EkISAoFBjIAAQQPhrrvumge2zoIUDdiW+3Gd8wq89NJL2dW+ww475GmKa6+9NvFKIAirr756
+sY3vpFd8vLjqXD8b3/7WyYK888/f7r55pvzc6tWuemArbfeOq9uMBjPNddcOQ6gWOEGd25+JKbq
whcQOPnkk2fPBKvfVElXCSGQZ5kyUC/fTzzxxFwmBGjJJZfMZANZUNdVVlkle0vkXw1ARA4k5VEn
SyOtyBCTYFoDQeKhKXXoqlxxLhBoRwSCJLRjq0edmwYBg6ABkkUtwK6aWNgIAcudVWyqYOqpp84D
ocHR9MLJJ5+clwaywHkLBBoiDix1rngDunxZ01YTGEi57Mu8vgG06rkwDWC6QtCkuf155503ryow
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
JZdcMo099tiDur4fffRRevLJJ/Pf66+/nj7//PP0zjvvpLfffjvNOeecad11101f//rXB3UdonCB
QCDQPwRG+2JY6l8WcXcgEAh0hsD3vve9dPPNN6dFF100vfHGG+nf//53mmmmmdK+++6bVlhhhUFJ
FO6777702GOPpRdffDHdeuut6c4770wvvPBCoirGGmusNNpoo6WFFloo/e1vf0uTTz55Z1WP44FA
INACCIQnoQUaMaoweBGYY4450vzzz5823HDDPND+61//SieffHI64ogj8kA7xRRTDJrCIwNPPPFE
Ou+889Itt9ySpxWUb6655korr7xyGmeccbLnAElwbPzxxx80ZY+CBAKBQGMQCE9CY3CNXAOBjID5
+3HHHXekOITtttsunXXWWdlKRyIGQ4zC+eefn/74xz+m22+/PY0xxhhpkUUWydMiyMBiiy2Wvzse
KRAIBNoLgej17dXeUdsBRqDWnD1X/bnnnps+/PDD7MKvVSRTEw8++GAerGvlUeue/hw74IAD8vNW
WWWVNHTo0LT22munWWaZJROG/uQb9wYCgUBzIxAkobnbL0rfhAg8++yz2bswySSTdOpF+Mtf/pLd
/ltvvXXaYIMN0njjjdejmlpF8fzzz6eJJ544D/oCJe+///701ltv5XgCx5EAUwfVZKUC8oIs+Ayv
QRWd+B4ItC8CQRLat+2j5g1C4OWXX06WPRpsO65gsITw+uuvT9NPP30e+M3v10pXXXVVuu222/Lg
vuqqq/aYJFx22WXpyiuvTN/85jfTddddl0xnXHPNNemVV17JZRFjYLpjyy23HL4y4ZNPPkkzzDBD
Xq0w77zzBkGo1SBxLBBoUwSCJLRpw0e1G4eAJY+XX3552mGHHdLqq68+ktV+6aWX5hUOO++88/BB
ulZJttpqq/Too4/mwf2zzz6rdUnNY8cee2wmB59++mmeyrj22mvzdeIeeBUefvjh9H//9395OqFM
Y1i58Nprr+VVCzUzjYOBQCDQtgg0764ubdtkUfHBjoAVDDfccEP61a9+lfcVKOXlGXBsggkmSOut
t16XJGH99dfP8QjiFkxP9JQovP/++8OnMBCDeeaZJ3sQLF/0XMfsf1Bd+YxQ/Oc//0m8EJ4XKRAI
BAKBgkB4EgoSTfopGv3pp59OZfe7ySabLC2wwAJ5Z7/OXNlNWtWmKbagPySB1c6VL1lSaNmjaYgf
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
2s/HoW4AAAAASUVORK5CYII=" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-org29f1667">
<h2 id="org29f1667">Backpressure</h2>
<ul>
<li>Consumers ask for data</li>
<li>i.e. Producers produce on-demand <i>ONLY</i>.</li>

</ul>
</section>
</section>
<section>
<section id="slide-org2118d2b">
<h2 id="org2118d2b">Okay, some code now</h2>
</section>
</section>
<section>
<section id="slide-org3f38f6f">
<h2 id="org3f38f6f">First, a template</h2>
<div class="org-src-container">

<pre  class="src src-elixir"><span style="color: #597bc5;">defmodule</span> <span style="color: #fdb86b;">Consumer</span> <span style="color: #597bc5;">do</span>&#57344;&#57345;&#57345;
  <span style="color: #597bc5;">use</span> <span style="color: #fdb86b;">GenStage</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #597bc5;">def</span> <span style="color: #f9cf80;">start_link</span>(), <span style="color: #87cefa;">do:</span> <span style="color: #fdb86b;">GenStage</span>.start_link(<span style="color: #71b9f8;">__MODULE__</span>, <span style="color: #87cefa;">:ok</span>)&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #597bc5;">def</span> <span style="color: #f9cf80;">init</span>(<span style="color: #87cefa;">:ok</span>) <span style="color: #597bc5;">do</span>&#57344;&#57345;&#57345;
    <span style="color: #adadad; font-style: italic;"># </span><span style="color: #adadad; font-style: italic;">A slight abstraction leak here requires us to return something as the state</span>&#57344;&#57345;
    {<span style="color: #87cefa;">:consumer</span>, <span style="color: #87cefa;">:ok</span>}&#57344;&#57345;&#57345;
  <span style="color: #597bc5;">end</span>&#57344;&#57345;&#57345;
&#57344;&#57345;&#57345;
  <span style="color: #597bc5;">def</span> <span style="color: #f9cf80;">handle_events</span>(cities, <span style="color: #adadad; font-style: italic;">_from</span>, state) <span style="color: #597bc5;">do</span>&#57344;&#57345;&#57345;
    <span style="color: #c6b8fc;">aggregated_cities</span> = <span style="color: #fdb86b;">Enum</span>.reduce(&#57344;&#57345;&#57345;
      cities,&#57344;&#57345;&#57345;
      %{},&#57344;&#57345;&#57345;
      <span style="color: #597bc5;">fn</span>(city, acc) -&gt; <span style="color: #fdb86b;">Map</span>.update(acc, city, 1, &amp;(&amp;1 + 1)) <span style="color: #597bc5;">end</span>&#57344;&#57345;&#57345;
    )&#57344;&#57345;&#57345;
    <span style="color: #fdb86b;">IO</span>.inspect aggregated_cities&#57344;&#57345;&#57345;
    <span style="color: #adadad; font-style: italic;"># </span><span style="color: #adadad; font-style: italic;">A slight abstraction leak here requires us to return an empty list</span>&#57344;&#57345;&#57345;
    {<span style="color: #87cefa;">:noreply</span>, [], state}&#57344;&#57345;&#57345;
  <span style="color: #597bc5;">end</span>&#57344;&#57345;&#57345;
<span style="color: #597bc5;">end</span>
</pre>
</div>
</section>
</section>
</div>
</div>
<script>
/*! head.core - v1.0.2 */
(function(n,t){"use strict";function r(n){a[a.length]=n}function k(n){var t=new RegExp(" ?\\b"+n+"\\b");c.className=c.className.replace(t,"")}function p(n,t){for(var i=0,r=n.length;i<r;i++)t.call(n,n[i],i)}function tt(){var t,e,f,o;c.className=c.className.replace(/ (w-|eq-|gt-|gte-|lt-|lte-|portrait|no-portrait|landscape|no-landscape)\d+/g,"");t=n.innerWidth||c.clientWidth;e=n.outerWidth||n.screen.width;u.screen.innerWidth=t;u.screen.outerWidth=e;r("w-"+t);p(i.screens,function(n){t>n?(i.screensCss.gt&&r("gt-"+n),i.screensCss.gte&&r("gte-"+n)):t<n?(i.screensCss.lt&&r("lt-"+n),i.screensCss.lte&&r("lte-"+n)):t===n&&(i.screensCss.lte&&r("lte-"+n),i.screensCss.eq&&r("e-q"+n),i.screensCss.gte&&r("gte-"+n))});f=n.innerHeight||c.clientHeight;o=n.outerHeight||n.screen.height;u.screen.innerHeight=f;u.screen.outerHeight=o;u.feature("portrait",f>t);u.feature("landscape",f<t)}function it(){n.clearTimeout(b);b=n.setTimeout(tt,50)}var y=n.document,rt=n.navigator,ut=n.location,c=y.documentElement,a=[],i={screens:[240,320,480,640,768,800,1024,1280,1440,1680,1920],screensCss:{gt:!0,gte:!1,lt:!0,lte:!1,eq:!1},browsers:[{ie:{min:6,max:11}}],browserCss:{gt:!0,gte:!1,lt:!0,lte:!1,eq:!0},html5:!0,page:"-page",section:"-section",head:"head"},v,u,s,w,o,h,l,d,f,g,nt,e,b;if(n.head_conf)for(v in n.head_conf)n.head_conf[v]!==t&&(i[v]=n.head_conf[v]);u=n[i.head]=function(){u.ready.apply(null,arguments)};u.feature=function(n,t,i){return n?(Object.prototype.toString.call(t)==="[object Function]"&&(t=t.call()),r((t?"":"no-")+n),u[n]=!!t,i||(k("no-"+n),k(n),u.feature()),u):(c.className+=" "+a.join(" "),a=[],u)};u.feature("js",!0);s=rt.userAgent.toLowerCase();w=/mobile|android|kindle|silk|midp|phone|(windows .+arm|touch)/.test(s);u.feature("mobile",w,!0);u.feature("desktop",!w,!0);s=/(chrome|firefox)[ \/]([\w.]+)/.exec(s)||/(iphone|ipad|ipod)(?:.*version)?[ \/]([\w.]+)/.exec(s)||/(android)(?:.*version)?[ \/]([\w.]+)/.exec(s)||/(webkit|opera)(?:.*version)?[ \/]([\w.]+)/.exec(s)||/(msie) ([\w.]+)/.exec(s)||/(trident).+rv:(\w.)+/.exec(s)||[];o=s[1];h=parseFloat(s[2]);switch(o){case"msie":case"trident":o="ie";h=y.documentMode||h;break;case"firefox":o="ff";break;case"ipod":case"ipad":case"iphone":o="ios";break;case"webkit":o="safari"}for(u.browser={name:o,version:h},u.browser[o]=!0,l=0,d=i.browsers.length;l<d;l++)for(f in i.browsers[l])if(o===f)for(r(f),g=i.browsers[l][f].min,nt=i.browsers[l][f].max,e=g;e<=nt;e++)h>e?(i.browserCss.gt&&r("gt-"+f+e),i.browserCss.gte&&r("gte-"+f+e)):h<e?(i.browserCss.lt&&r("lt-"+f+e),i.browserCss.lte&&r("lte-"+f+e)):h===e&&(i.browserCss.lte&&r("lte-"+f+e),i.browserCss.eq&&r("eq-"+f+e),i.browserCss.gte&&r("gte-"+f+e));else r("no-"+f);r(o);r(o+parseInt(h,10));i.html5&&o==="ie"&&h<9&&p("abbr|article|aside|audio|canvas|details|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|progress|section|summary|time|video".split("|"),function(n){y.createElement(n)});p(ut.pathname.split("/"),function(n,u){if(this.length>2&&this[u+1]!==t)u&&r(this.slice(u,u+1).join("-").toLowerCase()+i.section);else{var f=n||"index",e=f.indexOf(".");e>0&&(f=f.substring(0,e));c.id=f.toLowerCase()+i.page;u||r("root"+i.section)}});u.screen={height:n.screen.height,width:n.screen.width};tt();b=0;n.addEventListener?n.addEventListener("resize",it,!1):n.attachEvent("onresize",it)})(window);
/*! head.css3 - v1.0.0 */
(function(n,t){"use strict";function a(n){for(var r in n)if(i[n[r]]!==t)return!0;return!1}function r(n){var t=n.charAt(0).toUpperCase()+n.substr(1),i=(n+" "+c.join(t+" ")+t).split(" ");return!!a(i)}var h=n.document,o=h.createElement("i"),i=o.style,s=" -o- -moz- -ms- -webkit- -khtml- ".split(" "),c="Webkit Moz O ms Khtml".split(" "),l=n.head_conf&&n.head_conf.head||"head",u=n[l],f={gradient:function(){var n="background-image:";return i.cssText=(n+s.join("gradient(linear,left top,right bottom,from(#9f9),to(#fff));"+n)+s.join("linear-gradient(left top,#eee,#fff);"+n)).slice(0,-n.length),!!i.backgroundImage},rgba:function(){return i.cssText="background-color:rgba(0,0,0,0.5)",!!i.backgroundColor},opacity:function(){return o.style.opacity===""},textshadow:function(){return i.textShadow===""},multiplebgs:function(){i.cssText="background:url(https://),url(https://),red url(https://)";var n=(i.background||"").match(/url/g);return Object.prototype.toString.call(n)==="[object Array]"&&n.length===3},boxshadow:function(){return r("boxShadow")},borderimage:function(){return r("borderImage")},borderradius:function(){return r("borderRadius")},cssreflections:function(){return r("boxReflect")},csstransforms:function(){return r("transform")},csstransitions:function(){return r("transition")},touch:function(){return"ontouchstart"in n},retina:function(){return n.devicePixelRatio>1},fontface:function(){var t=u.browser.name,n=u.browser.version;switch(t){case"ie":return n>=9;case"chrome":return n>=13;case"ff":return n>=6;case"ios":return n>=5;case"android":return!1;case"webkit":return n>=5.1;case"opera":return n>=10;default:return!1}}};for(var e in f)f[e]&&u.feature(e,f[e].call(),!0);u.feature()})(window);
/*! head.load - v1.0.3 */
(function(n,t){"use strict";function w(){}function u(n,t){if(n){typeof n=="object"&&(n=[].slice.call(n));for(var i=0,r=n.length;i<r;i++)t.call(n,n[i],i)}}function it(n,i){var r=Object.prototype.toString.call(i).slice(8,-1);return i!==t&&i!==null&&r===n}function s(n){return it("Function",n)}function a(n){return it("Array",n)}function et(n){var i=n.split("/"),t=i[i.length-1],r=t.indexOf("?");return r!==-1?t.substring(0,r):t}function f(n){(n=n||w,n._done)||(n(),n._done=1)}function ot(n,t,r,u){var f=typeof n=="object"?n:{test:n,success:!t?!1:a(t)?t:[t],failure:!r?!1:a(r)?r:[r],callback:u||w},e=!!f.test;return e&&!!f.success?(f.success.push(f.callback),i.load.apply(null,f.success)):e||!f.failure?u():(f.failure.push(f.callback),i.load.apply(null,f.failure)),i}function v(n){var t={},i,r;if(typeof n=="object")for(i in n)!n[i]||(t={name:i,url:n[i]});else t={name:et(n),url:n};return(r=c[t.name],r&&r.url===t.url)?r:(c[t.name]=t,t)}function y(n){n=n||c;for(var t in n)if(n.hasOwnProperty(t)&&n[t].state!==l)return!1;return!0}function st(n){n.state=ft;u(n.onpreload,function(n){n.call()})}function ht(n){n.state===t&&(n.state=nt,n.onpreload=[],rt({url:n.url,type:"cache"},function(){st(n)}))}function ct(){var n=arguments,t=n[n.length-1],r=[].slice.call(n,1),f=r[0];return(s(t)||(t=null),a(n[0]))?(n[0].push(t),i.load.apply(null,n[0]),i):(f?(u(r,function(n){s(n)||!n||ht(v(n))}),b(v(n[0]),s(f)?f:function(){i.load.apply(null,r)})):b(v(n[0])),i)}function lt(){var n=arguments,t=n[n.length-1],r={};return(s(t)||(t=null),a(n[0]))?(n[0].push(t),i.load.apply(null,n[0]),i):(u(n,function(n){n!==t&&(n=v(n),r[n.name]=n)}),u(n,function(n){n!==t&&(n=v(n),b(n,function(){y(r)&&f(t)}))}),i)}function b(n,t){if(t=t||w,n.state===l){t();return}if(n.state===tt){i.ready(n.name,t);return}if(n.state===nt){n.onpreload.push(function(){b(n,t)});return}n.state=tt;rt(n,function(){n.state=l;t();u(h[n.name],function(n){f(n)});o&&y()&&u(h.ALL,function(n){f(n)})})}function at(n){n=n||"";var t=n.split("?")[0].split(".");return t[t.length-1].toLowerCase()}function rt(t,i){function e(t){t=t||n.event;u.onload=u.onreadystatechange=u.onerror=null;i()}function o(f){f=f||n.event;(f.type==="load"||/loaded|complete/.test(u.readyState)&&(!r.documentMode||r.documentMode<9))&&(n.clearTimeout(t.errorTimeout),n.clearTimeout(t.cssTimeout),u.onload=u.onreadystatechange=u.onerror=null,i())}function s(){if(t.state!==l&&t.cssRetries<=20){for(var i=0,f=r.styleSheets.length;i<f;i++)if(r.styleSheets[i].href===u.href){o({type:"load"});return}t.cssRetries++;t.cssTimeout=n.setTimeout(s,250)}}var u,h,f;i=i||w;h=at(t.url);h==="css"?(u=r.createElement("link"),u.type="text/"+(t.type||"css"),u.rel="stylesheet",u.href=t.url,t.cssRetries=0,t.cssTimeout=n.setTimeout(s,500)):(u=r.createElement("script"),u.type="text/"+(t.type||"javascript"),u.src=t.url);u.onload=u.onreadystatechange=o;u.onerror=e;u.async=!1;u.defer=!1;t.errorTimeout=n.setTimeout(function(){e({type:"timeout"})},7e3);f=r.head||r.getElementsByTagName("head")[0];f.insertBefore(u,f.lastChild)}function vt(){for(var t,u=r.getElementsByTagName("script"),n=0,f=u.length;n<f;n++)if(t=u[n].getAttribute("data-headjs-load"),!!t){i.load(t);return}}function yt(n,t){var v,p,e;return n===r?(o?f(t):d.push(t),i):(s(n)&&(t=n,n="ALL"),a(n))?(v={},u(n,function(n){v[n]=c[n];i.ready(n,function(){y(v)&&f(t)})}),i):typeof n!="string"||!s(t)?i:(p=c[n],p&&p.state===l||n==="ALL"&&y()&&o)?(f(t),i):(e=h[n],e?e.push(t):e=h[n]=[t],i)}function e(){if(!r.body){n.clearTimeout(i.readyTimeout);i.readyTimeout=n.setTimeout(e,50);return}o||(o=!0,vt(),u(d,function(n){f(n)}))}function k(){r.addEventListener?(r.removeEventListener("DOMContentLoaded",k,!1),e()):r.readyState==="complete"&&(r.detachEvent("onreadystatechange",k),e())}var r=n.document,d=[],h={},c={},ut="async"in r.createElement("script")||"MozAppearance"in r.documentElement.style||n.opera,o,g=n.head_conf&&n.head_conf.head||"head",i=n[g]=n[g]||function(){i.ready.apply(null,arguments)},nt=1,ft=2,tt=3,l=4,p;if(r.readyState==="complete")e();else if(r.addEventListener)r.addEventListener("DOMContentLoaded",k,!1),n.addEventListener("load",e,!1);else{r.attachEvent("onreadystatechange",k);n.attachEvent("onload",e);p=!1;try{p=!n.frameElement&&r.documentElement}catch(wt){}p&&p.doScroll&&function pt(){if(!o){try{p.doScroll("left")}catch(t){n.clearTimeout(i.readyTimeout);i.readyTimeout=n.setTimeout(pt,50);return}e()}}()}i.load=i.js=ut?lt:ct;i.test=ot;i.ready=yt;i.ready(r,function(){y()&&u(h.ALL,function(n){f(n)});i.feature&&i.feature("domloaded",!0)})})(window);
/*
//# sourceMappingURL=head.min.js.map
*/
/*!
 * reveal.js
 * http://revealjs.com
 * MIT licensed
 *
 * Copyright (C) 2017 Hakim El Hattab, http://hakim.se
 */
(function( root, factory ) {
        if( typeof define === 'function' && define.amd ) {
                // AMD. Register as an anonymous module.
                define( function() {
                        root.Reveal = factory();
                        return root.Reveal;
                } );
        } else if( typeof exports === 'object' ) {
                // Node. Does not work with strict CommonJS.
                module.exports = factory();
        } else {
                // Browser globals.
                root.Reveal = factory();
        }
}( this, function() {

        'use strict';

        var Reveal;

        // The reveal.js version
        var VERSION = '3.6.0';

        var SLIDES_SELECTOR = '.slides section',
                HORIZONTAL_SLIDES_SELECTOR = '.slides>section',
                VERTICAL_SLIDES_SELECTOR = '.slides>section.present>section',
                HOME_SLIDE_SELECTOR = '.slides>section:first-of-type',
                UA = navigator.userAgent,

                // Configuration defaults, can be overridden at initialization time
                config = {

                        // The "normal" size of the presentation, aspect ratio will be preserved
                        // when the presentation is scaled to fit different resolutions
                        width: 960,
                        height: 700,

                        // Factor of the display size that should remain empty around the content
                        margin: 0.04,

                        // Bounds for smallest/largest possible scale to apply to content
                        minScale: 0.2,
                        maxScale: 2.0,

                        // Display presentation control arrows
                        controls: true,

                        // Help the user learn the controls by providing hints, for example by
                        // bouncing the down arrow when they first encounter a vertical slide
                        controlsTutorial: true,

                        // Determines where controls appear, "edges" or "bottom-right"
                        controlsLayout: 'bottom-right',

                        // Visibility rule for backwards navigation arrows; "faded", "hidden"
                        // or "visible"
                        controlsBackArrows: 'faded',

                        // Display a presentation progress bar
                        progress: true,

                        // Display the page number of the current slide
                        slideNumber: false,

                        // Determine which displays to show the slide number on
                        showSlideNumber: 'all',

                        // Push each slide change to the browser history
                        history: false,

                        // Enable keyboard shortcuts for navigation
                        keyboard: true,

                        // Optional function that blocks keyboard events when retuning false
                        keyboardCondition: null,

                        // Enable the slide overview mode
                        overview: true,

                        // Vertical centering of slides
                        center: true,

                        // Enables touch navigation on devices with touch input
                        touch: true,

                        // Loop the presentation
                        loop: false,

                        // Change the presentation direction to be RTL
                        rtl: false,

                        // Randomizes the order of slides each time the presentation loads
                        shuffle: false,

                        // Turns fragments on and off globally
                        fragments: true,

                        // Flags if the presentation is running in an embedded mode,
                        // i.e. contained within a limited portion of the screen
                        embedded: false,

                        // Flags if we should show a help overlay when the question-mark
                        // key is pressed
                        help: true,

                        // Flags if it should be possible to pause the presentation (blackout)
                        pause: true,

                        // Flags if speaker notes should be visible to all viewers
                        showNotes: false,

                        // Global override for autolaying embedded media (video/audio/iframe)
                        // - null:   Media will only autoplay if data-autoplay is present
                        // - true:   All media will autoplay, regardless of individual setting
                        // - false:  No media will autoplay, regardless of individual setting
                        autoPlayMedia: null,

                        // Controls automatic progression to the next slide
                        // - 0:      Auto-sliding only happens if the data-autoslide HTML attribute
                        //           is present on the current slide or fragment
                        // - 1+:     All slides will progress automatically at the given interval
                        // - false:  No auto-sliding, even if data-autoslide is present
                        autoSlide: 0,

                        // Stop auto-sliding after user input
                        autoSlideStoppable: true,

                        // Use this method for navigation when auto-sliding (defaults to navigateNext)
                        autoSlideMethod: null,

                        // Enable slide navigation via mouse wheel
                        mouseWheel: false,

                        // Apply a 3D roll to links on hover
                        rollingLinks: false,

                        // Hides the address bar on mobile devices
                        hideAddressBar: true,

                        // Opens links in an iframe preview overlay
                        // Add `data-preview-link` and `data-preview-link="false"` to customise each link
                        // individually
                        previewLinks: false,

                        // Exposes the reveal.js API through window.postMessage
                        postMessage: true,

                        // Dispatches all reveal.js events to the parent window through postMessage
                        postMessageEvents: false,

                        // Focuses body when page changes visibility to ensure keyboard shortcuts work
                        focusBodyOnPageVisibilityChange: true,

                        // Transition style
                        transition: 'slide', // none/fade/slide/convex/concave/zoom

                        // Transition speed
                        transitionSpeed: 'default', // default/fast/slow

                        // Transition style for full page slide backgrounds
                        backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom

                        // Parallax background image
                        parallaxBackgroundImage: '', // CSS syntax, e.g. "a.jpg"

                        // Parallax background size
                        parallaxBackgroundSize: '', // CSS syntax, e.g. "3000px 2000px"

                        // Amount of pixels to move the parallax background per slide step
                        parallaxBackgroundHorizontal: null,
                        parallaxBackgroundVertical: null,

                        // The maximum number of pages a single slide can expand onto when printing
                        // to PDF, unlimited by default
                        pdfMaxPagesPerSlide: Number.POSITIVE_INFINITY,

                        // Offset used to reduce the height of content within exported PDF pages.
                        // This exists to account for environment differences based on how you
                        // print to PDF. CLI printing options, like phantomjs and wkpdf, can end
                        // on precisely the total height of the document whereas in-browser
                        // printing has to end one pixel before.
                        pdfPageHeightOffset: -1,

                        // Number of slides away from the current that are visible
                        viewDistance: 3,

                        // The display mode that will be used to show slides
                        display: 'block',

                        // Script dependencies to load
                        dependencies: []

                },

                // Flags if Reveal.initialize() has been called
                initialized = false,

                // Flags if reveal.js is loaded (has dispatched the 'ready' event)
                loaded = false,

                // Flags if the overview mode is currently active
                overview = false,

                // Holds the dimensions of our overview slides, including margins
                overviewSlideWidth = null,
                overviewSlideHeight = null,

                // The horizontal and vertical index of the currently active slide
                indexh,
                indexv,

                // The previous and current slide HTML elements
                previousSlide,
                currentSlide,

                previousBackground,

                // Remember which directions that the user has navigated towards
                hasNavigatedRight = false,
                hasNavigatedDown = false,

                // Slides may hold a data-state attribute which we pick up and apply
                // as a class to the body. This list contains the combined state of
                // all current slides.
                state = [],

                // The current scale of the presentation (see width/height config)
                scale = 1,

                // CSS transform that is currently applied to the slides container,
                // split into two groups
                slidesTransform = { layout: '', overview: '' },

                // Cached references to DOM elements
                dom = {},

                // Features supported by the browser, see #checkCapabilities()
                features = {},

                // Client is a mobile device, see #checkCapabilities()
                isMobileDevice,

                // Client is a desktop Chrome, see #checkCapabilities()
                isChrome,

                // Throttles mouse wheel navigation
                lastMouseWheelStep = 0,

                // Delays updates to the URL due to a Chrome thumbnailer bug
                writeURLTimeout = 0,

                // Flags if the interaction event listeners are bound
                eventsAreBound = false,

                // The current auto-slide duration
                autoSlide = 0,

                // Auto slide properties
                autoSlidePlayer,
                autoSlideTimeout = 0,
                autoSlideStartTime = -1,
                autoSlidePaused = false,

                // Holds information about the currently ongoing touch input
                touch = {
                        startX: 0,
                        startY: 0,
                        startSpan: 0,
                        startCount: 0,
                        captured: false,
                        threshold: 40
                },

                // Holds information about the keyboard shortcuts
                keyboardShortcuts = {
                        'N  ,  SPACE':			'Next slide',
                        'P':					'Previous slide',
                        '&#8592;  ,  H':		'Navigate left',
                        '&#8594;  ,  L':		'Navigate right',
                        '&#8593;  ,  K':		'Navigate up',
                        '&#8595;  ,  J':		'Navigate down',
                        'Home':					'First slide',
                        'End':					'Last slide',
                        'B  ,  .':				'Pause',
                        'F':					'Fullscreen',
                        'ESC, O':				'Slide overview'
                };

        /**
         * Starts up the presentation if the client is capable.
         */
        function initialize( options ) {

                // Make sure we only initialize once
                if( initialized === true ) return;

                initialized = true;

                checkCapabilities();

                if( !features.transforms2d && !features.transforms3d ) {
                        document.body.setAttribute( 'class', 'no-transforms' );

                        // Since JS won't be running any further, we load all lazy
                        // loading elements upfront
                        var images = toArray( document.getElementsByTagName( 'img' ) ),
                                iframes = toArray( document.getElementsByTagName( 'iframe' ) );

                        var lazyLoadable = images.concat( iframes );

                        for( var i = 0, len = lazyLoadable.length; i < len; i++ ) {
                                var element = lazyLoadable[i];
                                if( element.getAttribute( 'data-src' ) ) {
                                        element.setAttribute( 'src', element.getAttribute( 'data-src' ) );
                                        element.removeAttribute( 'data-src' );
                                }
                        }

                        // If the browser doesn't support core features we won't be
                        // using JavaScript to control the presentation
                        return;
                }

                // Cache references to key DOM elements
                dom.wrapper = document.querySelector( '.reveal' );
                dom.slides = document.querySelector( '.reveal .slides' );

                // Force a layout when the whole page, incl fonts, has loaded
                window.addEventListener( 'load', layout, false );

                var query = Reveal.getQueryHash();

                // Do not accept new dependencies via query config to avoid
                // the potential of malicious script injection
                if( typeof query['dependencies'] !== 'undefined' ) delete query['dependencies'];

                // Copy options over to our config object
                extend( config, options );
                extend( config, query );

                // Hide the address bar in mobile browsers
                hideAddressBar();

                // Loads the dependencies and continues to #start() once done
                load();

        }

        /**
         * Inspect the client to see what it's capable of, this
         * should only happens once per runtime.
         */
        function checkCapabilities() {

                isMobileDevice = /(iphone|ipod|ipad|android)/gi.test( UA );
                isChrome = /chrome/i.test( UA ) && !/edge/i.test( UA );

                var testElement = document.createElement( 'div' );

                features.transforms3d = 'WebkitPerspective' in testElement.style ||
                                                                'MozPerspective' in testElement.style ||
                                                                'msPerspective' in testElement.style ||
                                                                'OPerspective' in testElement.style ||
                                                                'perspective' in testElement.style;

                features.transforms2d = 'WebkitTransform' in testElement.style ||
                                                                'MozTransform' in testElement.style ||
                                                                'msTransform' in testElement.style ||
                                                                'OTransform' in testElement.style ||
                                                                'transform' in testElement.style;

                features.requestAnimationFrameMethod = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
                features.requestAnimationFrame = typeof features.requestAnimationFrameMethod === 'function';

                features.canvas = !!document.createElement( 'canvas' ).getContext;

                // Transitions in the overview are disabled in desktop and
                // Safari due to lag
                features.overviewTransitions = !/Version\/[\d\.]+.*Safari/.test( UA );

                // Flags if we should use zoom instead of transform to scale
                // up slides. Zoom produces crisper results but has a lot of
                // xbrowser quirks so we only use it in whitelsited browsers.
                features.zoom = 'zoom' in testElement.style && !isMobileDevice &&
                                                ( isChrome || /Version\/[\d\.]+.*Safari/.test( UA ) );

        }

    /**
     * Loads the dependencies of reveal.js. Dependencies are
     * defined via the configuration option 'dependencies'
     * and will be loaded prior to starting/binding reveal.js.
     * Some dependencies may have an 'async' flag, if so they
     * will load after reveal.js has been started up.
     */
        function load() {

                var scripts = [],
                        scriptsAsync = [],
                        scriptsToPreload = 0;

                // Called once synchronous scripts finish loading
                function proceed() {
                        if( scriptsAsync.length ) {
                                // Load asynchronous scripts
                                head.js.apply( null, scriptsAsync );
                        }

                        start();
                }

                function loadScript( s ) {
                        head.ready( s.src.match( /([\w\d_\-]*)\.?js$|[^\\\/]*$/i )[0], function() {
                                // Extension may contain callback functions
                                if( typeof s.callback === 'function' ) {
                                        s.callback.apply( this );
                                }

                                if( --scriptsToPreload === 0 ) {
                                        proceed();
                                }
                        });
                }

                for( var i = 0, len = config.dependencies.length; i < len; i++ ) {
                        var s = config.dependencies[i];

                        // Load if there's no condition or the condition is truthy
                        if( !s.condition || s.condition() ) {
                                if( s.async ) {
                                        scriptsAsync.push( s.src );
                                }
                                else {
                                        scripts.push( s.src );
                                }

                                loadScript( s );
                        }
                }

                if( scripts.length ) {
                        scriptsToPreload = scripts.length;

                        // Load synchronous scripts
                        head.js.apply( null, scripts );
                }
                else {
                        proceed();
                }

        }

        /**
         * Starts up reveal.js by binding input events and navigating
         * to the current URL deeplink if there is one.
         */
        function start() {

                loaded = true;

                // Make sure we've got all the DOM elements we need
                setupDOM();

                // Listen to messages posted to this window
                setupPostMessage();

                // Prevent the slides from being scrolled out of view
                setupScrollPrevention();

                // Resets all vertical slides so that only the first is visible
                resetVerticalSlides();

                // Updates the presentation to match the current configuration values
                configure();

                // Read the initial hash
                readURL();

                // Update all backgrounds
                updateBackground( true );

                // Notify listeners that the presentation is ready but use a 1ms
                // timeout to ensure it's not fired synchronously after #initialize()
                setTimeout( function() {
                        // Enable transitions now that we're loaded
                        dom.slides.classList.remove( 'no-transition' );

                        dom.wrapper.classList.add( 'ready' );

                        dispatchEvent( 'ready', {
                                'indexh': indexh,
                                'indexv': indexv,
                                'currentSlide': currentSlide
                        } );
                }, 1 );

                // Special setup and config is required when printing to PDF
                if( isPrintingPDF() ) {
                        removeEventListeners();

                        // The document needs to have loaded for the PDF layout
                        // measurements to be accurate
                        if( document.readyState === 'complete' ) {
                                setupPDF();
                        }
                        else {
                                window.addEventListener( 'load', setupPDF );
                        }
                }

        }

        /**
         * Finds and stores references to DOM elements which are
         * required by the presentation. If a required element is
         * not found, it is created.
         */
        function setupDOM() {

                // Prevent transitions while we're loading
                dom.slides.classList.add( 'no-transition' );

                if( isMobileDevice ) {
                        dom.wrapper.classList.add( 'no-hover' );
                }
                else {
                        dom.wrapper.classList.remove( 'no-hover' );
                }

                if( /iphone/gi.test( UA ) ) {
                        dom.wrapper.classList.add( 'ua-iphone' );
                }
                else {
                        dom.wrapper.classList.remove( 'ua-iphone' );
                }

                // Background element
                dom.background = createSingletonNode( dom.wrapper, 'div', 'backgrounds', null );

                // Progress bar
                dom.progress = createSingletonNode( dom.wrapper, 'div', 'progress', '<span></span>' );
                dom.progressbar = dom.progress.querySelector( 'span' );

                // Arrow controls
                dom.controls = createSingletonNode( dom.wrapper, 'aside', 'controls',
                        '<button class="navigate-left" aria-label="previous slide"><div class="controls-arrow"></div></button>' +
                        '<button class="navigate-right" aria-label="next slide"><div class="controls-arrow"></div></button>' +
                        '<button class="navigate-up" aria-label="above slide"><div class="controls-arrow"></div></button>' +
                        '<button class="navigate-down" aria-label="below slide"><div class="controls-arrow"></div></button>' );

                // Slide number
                dom.slideNumber = createSingletonNode( dom.wrapper, 'div', 'slide-number', '' );

                // Element containing notes that are visible to the audience
                dom.speakerNotes = createSingletonNode( dom.wrapper, 'div', 'speaker-notes', null );
                dom.speakerNotes.setAttribute( 'data-prevent-swipe', '' );
                dom.speakerNotes.setAttribute( 'tabindex', '0' );

                // Overlay graphic which is displayed during the paused mode
                createSingletonNode( dom.wrapper, 'div', 'pause-overlay', null );

                dom.wrapper.setAttribute( 'role', 'application' );

                // There can be multiple instances of controls throughout the page
                dom.controlsLeft = toArray( document.querySelectorAll( '.navigate-left' ) );
                dom.controlsRight = toArray( document.querySelectorAll( '.navigate-right' ) );
                dom.controlsUp = toArray( document.querySelectorAll( '.navigate-up' ) );
                dom.controlsDown = toArray( document.querySelectorAll( '.navigate-down' ) );
                dom.controlsPrev = toArray( document.querySelectorAll( '.navigate-prev' ) );
                dom.controlsNext = toArray( document.querySelectorAll( '.navigate-next' ) );

                // The right and down arrows in the standard reveal.js controls
                dom.controlsRightArrow = dom.controls.querySelector( '.navigate-right' );
                dom.controlsDownArrow = dom.controls.querySelector( '.navigate-down' );

                dom.statusDiv = createStatusDiv();
        }

        /**
         * Creates a hidden div with role aria-live to announce the
         * current slide content. Hide the div off-screen to make it
         * available only to Assistive Technologies.
         *
         * @return {HTMLElement}
         */
        function createStatusDiv() {

                var statusDiv = document.getElementById( 'aria-status-div' );
                if( !statusDiv ) {
                        statusDiv = document.createElement( 'div' );
                        statusDiv.style.position = 'absolute';
                        statusDiv.style.height = '1px';
                        statusDiv.style.width = '1px';
                        statusDiv.style.overflow = 'hidden';
                        statusDiv.style.clip = 'rect( 1px, 1px, 1px, 1px )';
                        statusDiv.setAttribute( 'id', 'aria-status-div' );
                        statusDiv.setAttribute( 'aria-live', 'polite' );
                        statusDiv.setAttribute( 'aria-atomic','true' );
                        dom.wrapper.appendChild( statusDiv );
                }
                return statusDiv;

        }

        /**
         * Converts the given HTML element into a string of text
         * that can be announced to a screen reader. Hidden
         * elements are excluded.
         */
        function getStatusText( node ) {

                var text = '';

                // Text node
                if( node.nodeType === 3 ) {
                        text += node.textContent;
                }
                // Element node
                else if( node.nodeType === 1 ) {

                        var isAriaHidden = node.getAttribute( 'aria-hidden' );
                        var isDisplayHidden = window.getComputedStyle( node )['display'] === 'none';
                        if( isAriaHidden !== 'true' && !isDisplayHidden ) {

                                toArray( node.childNodes ).forEach( function( child ) {
                                        text += getStatusText( child );
                                } );

                        }

                }

                return text;

        }

        /**
         * Configures the presentation for printing to a static
         * PDF.
         */
        function setupPDF() {

                var slideSize = getComputedSlideSize( window.innerWidth, window.innerHeight );

                // Dimensions of the PDF pages
                var pageWidth = Math.floor( slideSize.width * ( 1 + config.margin ) ),
                        pageHeight = Math.floor( slideSize.height * ( 1 + config.margin ) );

                // Dimensions of slides within the pages
                var slideWidth = slideSize.width,
                        slideHeight = slideSize.height;

                // Let the browser know what page size we want to print
                injectStyleSheet( '@page{size:'+ pageWidth +'px '+ pageHeight +'px; margin: 0px;}' );

                // Limit the size of certain elements to the dimensions of the slide
                injectStyleSheet( '.reveal section>img, .reveal section>video, .reveal section>iframe{max-width: '+ slideWidth +'px; max-height:'+ slideHeight +'px}' );

                document.body.classList.add( 'print-pdf' );
                document.body.style.width = pageWidth + 'px';
                document.body.style.height = pageHeight + 'px';

                // Make sure stretch elements fit on slide
                layoutSlideContents( slideWidth, slideHeight );

                // Add each slide's index as attributes on itself, we need these
                // indices to generate slide numbers below
                toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( hslide, h ) {
                        hslide.setAttribute( 'data-index-h', h );

                        if( hslide.classList.contains( 'stack' ) ) {
                                toArray( hslide.querySelectorAll( 'section' ) ).forEach( function( vslide, v ) {
                                        vslide.setAttribute( 'data-index-h', h );
                                        vslide.setAttribute( 'data-index-v', v );
                                } );
                        }
                } );

                // Slide and slide background layout
                toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {

                        // Vertical stacks are not centred since their section
                        // children will be
                        if( slide.classList.contains( 'stack' ) === false ) {
                                // Center the slide inside of the page, giving the slide some margin
                                var left = ( pageWidth - slideWidth ) / 2,
                                        top = ( pageHeight - slideHeight ) / 2;

                                var contentHeight = slide.scrollHeight;
                                var numberOfPages = Math.max( Math.ceil( contentHeight / pageHeight ), 1 );

                                // Adhere to configured pages per slide limit
                                numberOfPages = Math.min( numberOfPages, config.pdfMaxPagesPerSlide );

                                // Center slides vertically
                                if( numberOfPages === 1 && config.center || slide.classList.contains( 'center' ) ) {
                                        top = Math.max( ( pageHeight - contentHeight ) / 2, 0 );
                                }

                                // Wrap the slide in a page element and hide its overflow
                                // so that no page ever flows onto another
                                var page = document.createElement( 'div' );
                                page.className = 'pdf-page';
                                page.style.height = ( ( pageHeight + config.pdfPageHeightOffset ) * numberOfPages ) + 'px';
                                slide.parentNode.insertBefore( page, slide );
                                page.appendChild( slide );

                                // Position the slide inside of the page
                                slide.style.left = left + 'px';
                                slide.style.top = top + 'px';
                                slide.style.width = slideWidth + 'px';

                                if( slide.slideBackgroundElement ) {
                                        page.insertBefore( slide.slideBackgroundElement, slide );
                                }

                                // Inject notes if `showNotes` is enabled
                                if( config.showNotes ) {

                                        // Are there notes for this slide?
                                        var notes = getSlideNotes( slide );
                                        if( notes ) {

                                                var notesSpacing = 8;
                                                var notesLayout = typeof config.showNotes === 'string' ? config.showNotes : 'inline';
                                                var notesElement = document.createElement( 'div' );
                                                notesElement.classList.add( 'speaker-notes' );
                                                notesElement.classList.add( 'speaker-notes-pdf' );
                                                notesElement.setAttribute( 'data-layout', notesLayout );
                                                notesElement.innerHTML = notes;

                                                if( notesLayout === 'separate-page' ) {
                                                        page.parentNode.insertBefore( notesElement, page.nextSibling );
                                                }
                                                else {
                                                        notesElement.style.left = notesSpacing + 'px';
                                                        notesElement.style.bottom = notesSpacing + 'px';
                                                        notesElement.style.width = ( pageWidth - notesSpacing*2 ) + 'px';
                                                        page.appendChild( notesElement );
                                                }

                                        }

                                }

                                // Inject slide numbers if `slideNumbers` are enabled
                                if( config.slideNumber && /all|print/i.test( config.showSlideNumber ) ) {
                                        var slideNumberH = parseInt( slide.getAttribute( 'data-index-h' ), 10 ) + 1,
                                                slideNumberV = parseInt( slide.getAttribute( 'data-index-v' ), 10 ) + 1;

                                        var numberElement = document.createElement( 'div' );
                                        numberElement.classList.add( 'slide-number' );
                                        numberElement.classList.add( 'slide-number-pdf' );
                                        numberElement.innerHTML = formatSlideNumber( slideNumberH, '.', slideNumberV );
                                        page.appendChild( numberElement );
                                }
                        }

                } );

                // Show all fragments
                toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' .fragment' ) ).forEach( function( fragment ) {
                        fragment.classList.add( 'visible' );
                } );

                // Notify subscribers that the PDF layout is good to go
                dispatchEvent( 'pdf-ready' );

        }

        /**
         * This is an unfortunate necessity. Some actions  such as
         * an input field being focused in an iframe or using the
         * keyboard to expand text selection beyond the bounds of
         * a slide  can trigger our content to be pushed out of view.
         * This scrolling can not be prevented by hiding overflow in
         * CSS (we already do) so we have to resort to repeatedly
         * checking if the slides have been offset :(
         */
        function setupScrollPrevention() {

                setInterval( function() {
                        if( dom.wrapper.scrollTop !== 0 || dom.wrapper.scrollLeft !== 0 ) {
                                dom.wrapper.scrollTop = 0;
                                dom.wrapper.scrollLeft = 0;
                        }
                }, 1000 );

        }

        /**
         * Creates an HTML element and returns a reference to it.
         * If the element already exists the existing instance will
         * be returned.
         *
         * @param {HTMLElement} container
         * @param {string} tagname
         * @param {string} classname
         * @param {string} innerHTML
         *
         * @return {HTMLElement}
         */
        function createSingletonNode( container, tagname, classname, innerHTML ) {

                // Find all nodes matching the description
                var nodes = container.querySelectorAll( '.' + classname );

                // Check all matches to find one which is a direct child of
                // the specified container
                for( var i = 0; i < nodes.length; i++ ) {
                        var testNode = nodes[i];
                        if( testNode.parentNode === container ) {
                                return testNode;
                        }
                }

                // If no node was found, create it now
                var node = document.createElement( tagname );
                node.className = classname;
                if( typeof innerHTML === 'string' ) {
                        node.innerHTML = innerHTML;
                }
                container.appendChild( node );

                return node;

        }

        /**
         * Creates the slide background elements and appends them
         * to the background container. One element is created per
         * slide no matter if the given slide has visible background.
         */
        function createBackgrounds() {

                var printMode = isPrintingPDF();

                // Clear prior backgrounds
                dom.background.innerHTML = '';
                dom.background.classList.add( 'no-transition' );

                // Iterate over all horizontal slides
                toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( slideh ) {

                        var backgroundStack = createBackground( slideh, dom.background );

                        // Iterate over all vertical slides
                        toArray( slideh.querySelectorAll( 'section' ) ).forEach( function( slidev ) {

                                createBackground( slidev, backgroundStack );

                                backgroundStack.classList.add( 'stack' );

                        } );

                } );

                // Add parallax background if specified
                if( config.parallaxBackgroundImage ) {

                        dom.background.style.backgroundImage = 'url("' + config.parallaxBackgroundImage + '")';
                        dom.background.style.backgroundSize = config.parallaxBackgroundSize;

                        // Make sure the below properties are set on the element - these properties are
                        // needed for proper transitions to be set on the element via CSS. To remove
                        // annoying background slide-in effect when the presentation starts, apply
                        // these properties after short time delay
                        setTimeout( function() {
                                dom.wrapper.classList.add( 'has-parallax-background' );
                        }, 1 );

                }
                else {

                        dom.background.style.backgroundImage = '';
                        dom.wrapper.classList.remove( 'has-parallax-background' );

                }

        }

        /**
         * Creates a background for the given slide.
         *
         * @param {HTMLElement} slide
         * @param {HTMLElement} container The element that the background
         * should be appended to
         * @return {HTMLElement} New background div
         */
        function createBackground( slide, container ) {

                var data = {
                        background: slide.getAttribute( 'data-background' ),
                        backgroundSize: slide.getAttribute( 'data-background-size' ),
                        backgroundImage: slide.getAttribute( 'data-background-image' ),
                        backgroundVideo: slide.getAttribute( 'data-background-video' ),
                        backgroundIframe: slide.getAttribute( 'data-background-iframe' ),
                        backgroundColor: slide.getAttribute( 'data-background-color' ),
                        backgroundRepeat: slide.getAttribute( 'data-background-repeat' ),
                        backgroundPosition: slide.getAttribute( 'data-background-position' ),
                        backgroundTransition: slide.getAttribute( 'data-background-transition' )
                };

                var element = document.createElement( 'div' );

                // Carry over custom classes from the slide to the background
                element.className = 'slide-background ' + slide.className.replace( /present|past|future/, '' );

                if( data.background ) {
                        // Auto-wrap image urls in url(...)
                        if( /^(http|file|\/\/)/gi.test( data.background ) || /\.(svg|png|jpg|jpeg|gif|bmp)([?#]|$)/gi.test( data.background ) ) {
                                slide.setAttribute( 'data-background-image', data.background );
                        }
                        else {
                                element.style.background = data.background;
                        }
                }

                // Create a hash for this combination of background settings.
                // This is used to determine when two slide backgrounds are
                // the same.
                if( data.background || data.backgroundColor || data.backgroundImage || data.backgroundVideo || data.backgroundIframe ) {
                        element.setAttribute( 'data-background-hash', data.background +
                                                                                                                        data.backgroundSize +
                                                                                                                        data.backgroundImage +
                                                                                                                        data.backgroundVideo +
                                                                                                                        data.backgroundIframe +
                                                                                                                        data.backgroundColor +
                                                                                                                        data.backgroundRepeat +
                                                                                                                        data.backgroundPosition +
                                                                                                                        data.backgroundTransition );
                }

                // Additional and optional background properties
                if( data.backgroundSize ) element.style.backgroundSize = data.backgroundSize;
                if( data.backgroundSize ) element.setAttribute( 'data-background-size', data.backgroundSize );
                if( data.backgroundColor ) element.style.backgroundColor = data.backgroundColor;
                if( data.backgroundRepeat ) element.style.backgroundRepeat = data.backgroundRepeat;
                if( data.backgroundPosition ) element.style.backgroundPosition = data.backgroundPosition;
                if( data.backgroundTransition ) element.setAttribute( 'data-background-transition', data.backgroundTransition );

                container.appendChild( element );

                // If backgrounds are being recreated, clear old classes
                slide.classList.remove( 'has-dark-background' );
                slide.classList.remove( 'has-light-background' );

                slide.slideBackgroundElement = element;

                // If this slide has a background color, add a class that
                // signals if it is light or dark. If the slide has no background
                // color, no class will be set
                var computedBackgroundStyle = window.getComputedStyle( element );
                if( computedBackgroundStyle && computedBackgroundStyle.backgroundColor ) {
                        var rgb = colorToRgb( computedBackgroundStyle.backgroundColor );

                        // Ignore fully transparent backgrounds. Some browsers return
                        // rgba(0,0,0,0) when reading the computed background color of
                        // an element with no background
                        if( rgb && rgb.a !== 0 ) {
                                if( colorBrightness( computedBackgroundStyle.backgroundColor ) < 128 ) {
                                        slide.classList.add( 'has-dark-background' );
                                }
                                else {
                                        slide.classList.add( 'has-light-background' );
                                }
                        }
                }

                return element;

        }

        /**
         * Registers a listener to postMessage events, this makes it
         * possible to call all reveal.js API methods from another
         * window. For example:
         *
         * revealWindow.postMessage( JSON.stringify({
         *   method: 'slide',
         *   args: [ 2 ]
         * }), '*' );
         */
        function setupPostMessage() {

                if( config.postMessage ) {
                        window.addEventListener( 'message', function ( event ) {
                                var data = event.data;

                                // Make sure we're dealing with JSON
                                if( typeof data === 'string' && data.charAt( 0 ) === '{' && data.charAt( data.length - 1 ) === '}' ) {
                                        data = JSON.parse( data );

                                        // Check if the requested method can be found
                                        if( data.method && typeof Reveal[data.method] === 'function' ) {
                                                Reveal[data.method].apply( Reveal, data.args );
                                        }
                                }
                        }, false );
                }

        }

        /**
         * Applies the configuration settings from the config
         * object. May be called multiple times.
         *
         * @param {object} options
         */
        function configure( options ) {

                var oldTransition = config.transition;

                // New config options may be passed when this method
                // is invoked through the API after initialization
                if( typeof options === 'object' ) extend( config, options );

                // Abort if reveal.js hasn't finished loading, config
                // changes will be applied automatically once loading
                // finishes
                if( loaded === false ) return;

                var numberOfSlides = dom.wrapper.querySelectorAll( SLIDES_SELECTOR ).length;

                // Remove the previously configured transition class
                dom.wrapper.classList.remove( oldTransition );

                // Force linear transition based on browser capabilities
                if( features.transforms3d === false ) config.transition = 'linear';

                dom.wrapper.classList.add( config.transition );

                dom.wrapper.setAttribute( 'data-transition-speed', config.transitionSpeed );
                dom.wrapper.setAttribute( 'data-background-transition', config.backgroundTransition );

                dom.controls.style.display = config.controls ? 'block' : 'none';
                dom.progress.style.display = config.progress ? 'block' : 'none';

                dom.controls.setAttribute( 'data-controls-layout', config.controlsLayout );
                dom.controls.setAttribute( 'data-controls-back-arrows', config.controlsBackArrows );

                if( config.shuffle ) {
                        shuffle();
                }

                if( config.rtl ) {
                        dom.wrapper.classList.add( 'rtl' );
                }
                else {
                        dom.wrapper.classList.remove( 'rtl' );
                }

                if( config.center ) {
                        dom.wrapper.classList.add( 'center' );
                }
                else {
                        dom.wrapper.classList.remove( 'center' );
                }

                // Exit the paused mode if it was configured off
                if( config.pause === false ) {
                        resume();
                }

                if( config.showNotes ) {
                        dom.speakerNotes.setAttribute( 'data-layout', typeof config.showNotes === 'string' ? config.showNotes : 'inline' );
                }

                if( config.mouseWheel ) {
                        document.addEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF
                        document.addEventListener( 'mousewheel', onDocumentMouseScroll, false );
                }
                else {
                        document.removeEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF
                        document.removeEventListener( 'mousewheel', onDocumentMouseScroll, false );
                }

                // Rolling 3D links
                if( config.rollingLinks ) {
                        enableRollingLinks();
                }
                else {
                        disableRollingLinks();
                }

                // Iframe link previews
                if( config.previewLinks ) {
                        enablePreviewLinks();
                        disablePreviewLinks( '[data-preview-link=false]' );
                }
                else {
                        disablePreviewLinks();
                        enablePreviewLinks( '[data-preview-link]:not([data-preview-link=false])' );
                }

                // Remove existing auto-slide controls
                if( autoSlidePlayer ) {
                        autoSlidePlayer.destroy();
                        autoSlidePlayer = null;
                }

                // Generate auto-slide controls if needed
                if( numberOfSlides > 1 && config.autoSlide && config.autoSlideStoppable && features.canvas && features.requestAnimationFrame ) {
                        autoSlidePlayer = new Playback( dom.wrapper, function() {
                                return Math.min( Math.max( ( Date.now() - autoSlideStartTime ) / autoSlide, 0 ), 1 );
                        } );

                        autoSlidePlayer.on( 'click', onAutoSlidePlayerClick );
                        autoSlidePaused = false;
                }

                // When fragments are turned off they should be visible
                if( config.fragments === false ) {
                        toArray( dom.slides.querySelectorAll( '.fragment' ) ).forEach( function( element ) {
                                element.classList.add( 'visible' );
                                element.classList.remove( 'current-fragment' );
                        } );
                }

                // Slide numbers
                var slideNumberDisplay = 'none';
                if( config.slideNumber && !isPrintingPDF() ) {
                        if( config.showSlideNumber === 'all' ) {
                                slideNumberDisplay = 'block';
                        }
                        else if( config.showSlideNumber === 'speaker' && isSpeakerNotes() ) {
                                slideNumberDisplay = 'block';
                        }
                }

                dom.slideNumber.style.display = slideNumberDisplay;

                sync();

        }

        /**
         * Binds all event listeners.
         */
        function addEventListeners() {

                eventsAreBound = true;

                window.addEventListener( 'hashchange', onWindowHashChange, false );
                window.addEventListener( 'resize', onWindowResize, false );

                if( config.touch ) {
                        dom.wrapper.addEventListener( 'touchstart', onTouchStart, false );
                        dom.wrapper.addEventListener( 'touchmove', onTouchMove, false );
                        dom.wrapper.addEventListener( 'touchend', onTouchEnd, false );

                        // Support pointer-style touch interaction as well
                        if( window.navigator.pointerEnabled ) {
                                // IE 11 uses un-prefixed version of pointer events
                                dom.wrapper.addEventListener( 'pointerdown', onPointerDown, false );
                                dom.wrapper.addEventListener( 'pointermove', onPointerMove, false );
                                dom.wrapper.addEventListener( 'pointerup', onPointerUp, false );
                        }
                        else if( window.navigator.msPointerEnabled ) {
                                // IE 10 uses prefixed version of pointer events
                                dom.wrapper.addEventListener( 'MSPointerDown', onPointerDown, false );
                                dom.wrapper.addEventListener( 'MSPointerMove', onPointerMove, false );
                                dom.wrapper.addEventListener( 'MSPointerUp', onPointerUp, false );
                        }
                }

                if( config.keyboard ) {
                        document.addEventListener( 'keydown', onDocumentKeyDown, false );
                        document.addEventListener( 'keypress', onDocumentKeyPress, false );
                }

                if( config.progress && dom.progress ) {
                        dom.progress.addEventListener( 'click', onProgressClicked, false );
                }

                if( config.focusBodyOnPageVisibilityChange ) {
                        var visibilityChange;

                        if( 'hidden' in document ) {
                                visibilityChange = 'visibilitychange';
                        }
                        else if( 'msHidden' in document ) {
                                visibilityChange = 'msvisibilitychange';
                        }
                        else if( 'webkitHidden' in document ) {
                                visibilityChange = 'webkitvisibilitychange';
                        }

                        if( visibilityChange ) {
                                document.addEventListener( visibilityChange, onPageVisibilityChange, false );
                        }
                }

                // Listen to both touch and click events, in case the device
                // supports both
                var pointerEvents = [ 'touchstart', 'click' ];

                // Only support touch for Android, fixes double navigations in
                // stock browser
                if( UA.match( /android/gi ) ) {
                        pointerEvents = [ 'touchstart' ];
                }

                pointerEvents.forEach( function( eventName ) {
                        dom.controlsLeft.forEach( function( el ) { el.addEventListener( eventName, onNavigateLeftClicked, false ); } );
                        dom.controlsRight.forEach( function( el ) { el.addEventListener( eventName, onNavigateRightClicked, false ); } );
                        dom.controlsUp.forEach( function( el ) { el.addEventListener( eventName, onNavigateUpClicked, false ); } );
                        dom.controlsDown.forEach( function( el ) { el.addEventListener( eventName, onNavigateDownClicked, false ); } );
                        dom.controlsPrev.forEach( function( el ) { el.addEventListener( eventName, onNavigatePrevClicked, false ); } );
                        dom.controlsNext.forEach( function( el ) { el.addEventListener( eventName, onNavigateNextClicked, false ); } );
                } );

        }

        /**
         * Unbinds all event listeners.
         */
        function removeEventListeners() {

                eventsAreBound = false;

                document.removeEventListener( 'keydown', onDocumentKeyDown, false );
                document.removeEventListener( 'keypress', onDocumentKeyPress, false );
                window.removeEventListener( 'hashchange', onWindowHashChange, false );
                window.removeEventListener( 'resize', onWindowResize, false );

                dom.wrapper.removeEventListener( 'touchstart', onTouchStart, false );
                dom.wrapper.removeEventListener( 'touchmove', onTouchMove, false );
                dom.wrapper.removeEventListener( 'touchend', onTouchEnd, false );

                // IE11
                if( window.navigator.pointerEnabled ) {
                        dom.wrapper.removeEventListener( 'pointerdown', onPointerDown, false );
                        dom.wrapper.removeEventListener( 'pointermove', onPointerMove, false );
                        dom.wrapper.removeEventListener( 'pointerup', onPointerUp, false );
                }
                // IE10
                else if( window.navigator.msPointerEnabled ) {
                        dom.wrapper.removeEventListener( 'MSPointerDown', onPointerDown, false );
                        dom.wrapper.removeEventListener( 'MSPointerMove', onPointerMove, false );
                        dom.wrapper.removeEventListener( 'MSPointerUp', onPointerUp, false );
                }

                if ( config.progress && dom.progress ) {
                        dom.progress.removeEventListener( 'click', onProgressClicked, false );
                }

                [ 'touchstart', 'click' ].forEach( function( eventName ) {
                        dom.controlsLeft.forEach( function( el ) { el.removeEventListener( eventName, onNavigateLeftClicked, false ); } );
                        dom.controlsRight.forEach( function( el ) { el.removeEventListener( eventName, onNavigateRightClicked, false ); } );
                        dom.controlsUp.forEach( function( el ) { el.removeEventListener( eventName, onNavigateUpClicked, false ); } );
                        dom.controlsDown.forEach( function( el ) { el.removeEventListener( eventName, onNavigateDownClicked, false ); } );
                        dom.controlsPrev.forEach( function( el ) { el.removeEventListener( eventName, onNavigatePrevClicked, false ); } );
                        dom.controlsNext.forEach( function( el ) { el.removeEventListener( eventName, onNavigateNextClicked, false ); } );
                } );

        }

        /**
         * Extend object a with the properties of object b.
         * If there's a conflict, object b takes precedence.
         *
         * @param {object} a
         * @param {object} b
         */
        function extend( a, b ) {

                for( var i in b ) {
                        a[ i ] = b[ i ];
                }

                return a;

        }

        /**
         * Converts the target object to an array.
         *
         * @param {object} o
         * @return {object[]}
         */
        function toArray( o ) {

                return Array.prototype.slice.call( o );

        }

        /**
         * Utility for deserializing a value.
         *
         * @param {*} value
         * @return {*}
         */
        function deserialize( value ) {

                if( typeof value === 'string' ) {
                        if( value === 'null' ) return null;
                        else if( value === 'true' ) return true;
                        else if( value === 'false' ) return false;
                        else if( value.match( /^-?[\d\.]+$/ ) ) return parseFloat( value );
                }

                return value;

        }

        /**
         * Measures the distance in pixels between point a
         * and point b.
         *
         * @param {object} a point with x/y properties
         * @param {object} b point with x/y properties
         *
         * @return {number}
         */
        function distanceBetween( a, b ) {

                var dx = a.x - b.x,
                        dy = a.y - b.y;

                return Math.sqrt( dx*dx + dy*dy );

        }

        /**
         * Applies a CSS transform to the target element.
         *
         * @param {HTMLElement} element
         * @param {string} transform
         */
        function transformElement( element, transform ) {

                element.style.WebkitTransform = transform;
                element.style.MozTransform = transform;
                element.style.msTransform = transform;
                element.style.transform = transform;

        }

        /**
         * Applies CSS transforms to the slides container. The container
         * is transformed from two separate sources: layout and the overview
         * mode.
         *
         * @param {object} transforms
         */
        function transformSlides( transforms ) {

                // Pick up new transforms from arguments
                if( typeof transforms.layout === 'string' ) slidesTransform.layout = transforms.layout;
                if( typeof transforms.overview === 'string' ) slidesTransform.overview = transforms.overview;

                // Apply the transforms to the slides container
                if( slidesTransform.layout ) {
                        transformElement( dom.slides, slidesTransform.layout + ' ' + slidesTransform.overview );
                }
                else {
                        transformElement( dom.slides, slidesTransform.overview );
                }

        }

        /**
         * Injects the given CSS styles into the DOM.
         *
         * @param {string} value
         */
        function injectStyleSheet( value ) {

                var tag = document.createElement( 'style' );
                tag.type = 'text/css';
                if( tag.styleSheet ) {
                        tag.styleSheet.cssText = value;
                }
                else {
                        tag.appendChild( document.createTextNode( value ) );
                }
                document.getElementsByTagName( 'head' )[0].appendChild( tag );

        }

        /**
         * Find the closest parent that matches the given
         * selector.
         *
         * @param {HTMLElement} target The child element
         * @param {String} selector The CSS selector to match
         * the parents against
         *
         * @return {HTMLElement} The matched parent or null
         * if no matching parent was found
         */
        function closestParent( target, selector ) {

                var parent = target.parentNode;

                while( parent ) {

                        // There's some overhead doing this each time, we don't
                        // want to rewrite the element prototype but should still
                        // be enough to feature detect once at startup...
                        var matchesMethod = parent.matches || parent.matchesSelector || parent.msMatchesSelector;

                        // If we find a match, we're all set
                        if( matchesMethod && matchesMethod.call( parent, selector ) ) {
                                return parent;
                        }

                        // Keep searching
                        parent = parent.parentNode;

                }

                return null;

        }

        /**
         * Converts various color input formats to an {r:0,g:0,b:0} object.
         *
         * @param {string} color The string representation of a color
         * @example
         * colorToRgb('#000');
         * @example
         * colorToRgb('#000000');
         * @example
         * colorToRgb('rgb(0,0,0)');
         * @example
         * colorToRgb('rgba(0,0,0)');
         *
         * @return {{r: number, g: number, b: number, [a]: number}|null}
         */
        function colorToRgb( color ) {

                var hex3 = color.match( /^#([0-9a-f]{3})$/i );
                if( hex3 && hex3[1] ) {
                        hex3 = hex3[1];
                        return {
                                r: parseInt( hex3.charAt( 0 ), 16 ) * 0x11,
                                g: parseInt( hex3.charAt( 1 ), 16 ) * 0x11,
                                b: parseInt( hex3.charAt( 2 ), 16 ) * 0x11
                        };
                }

                var hex6 = color.match( /^#([0-9a-f]{6})$/i );
                if( hex6 && hex6[1] ) {
                        hex6 = hex6[1];
                        return {
                                r: parseInt( hex6.substr( 0, 2 ), 16 ),
                                g: parseInt( hex6.substr( 2, 2 ), 16 ),
                                b: parseInt( hex6.substr( 4, 2 ), 16 )
                        };
                }

                var rgb = color.match( /^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i );
                if( rgb ) {
                        return {
                                r: parseInt( rgb[1], 10 ),
                                g: parseInt( rgb[2], 10 ),
                                b: parseInt( rgb[3], 10 )
                        };
                }

                var rgba = color.match( /^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\,\s*([\d]+|[\d]*.[\d]+)\s*\)$/i );
                if( rgba ) {
                        return {
                                r: parseInt( rgba[1], 10 ),
                                g: parseInt( rgba[2], 10 ),
                                b: parseInt( rgba[3], 10 ),
                                a: parseFloat( rgba[4] )
                        };
                }

                return null;

        }

        /**
         * Calculates brightness on a scale of 0-255.
         *
         * @param {string} color See colorToRgb for supported formats.
         * @see {@link colorToRgb}
         */
        function colorBrightness( color ) {

                if( typeof color === 'string' ) color = colorToRgb( color );

                if( color ) {
                        return ( color.r * 299 + color.g * 587 + color.b * 114 ) / 1000;
                }

                return null;

        }

        /**
         * Returns the remaining height within the parent of the
         * target element.
         *
         * remaining height = [ configured parent height ] - [ current parent height ]
         *
         * @param {HTMLElement} element
         * @param {number} [height]
         */
        function getRemainingHeight( element, height ) {

                height = height || 0;

                if( element ) {
                        var newHeight, oldHeight = element.style.height;

                        // Change the .stretch element height to 0 in order find the height of all
                        // the other elements
                        element.style.height = '0px';
                        newHeight = height - element.parentNode.offsetHeight;

                        // Restore the old height, just in case
                        element.style.height = oldHeight + 'px';

                        return newHeight;
                }

                return height;

        }

        /**
         * Checks if this instance is being used to print a PDF.
         */
        function isPrintingPDF() {

                return ( /print-pdf/gi ).test( window.location.search );

        }

        /**
         * Hides the address bar if we're on a mobile device.
         */
        function hideAddressBar() {

                if( config.hideAddressBar && isMobileDevice ) {
                        // Events that should trigger the address bar to hide
                        window.addEventListener( 'load', removeAddressBar, false );
                        window.addEventListener( 'orientationchange', removeAddressBar, false );
                }

        }

        /**
         * Causes the address bar to hide on mobile devices,
         * more vertical space ftw.
         */
        function removeAddressBar() {

                setTimeout( function() {
                        window.scrollTo( 0, 1 );
                }, 10 );

        }

        /**
         * Dispatches an event of the specified type from the
         * reveal DOM element.
         */
        function dispatchEvent( type, args ) {

                var event = document.createEvent( 'HTMLEvents', 1, 2 );
                event.initEvent( type, true, true );
                extend( event, args );
                dom.wrapper.dispatchEvent( event );

                // If we're in an iframe, post each reveal.js event to the
                // parent window. Used by the notes plugin
                if( config.postMessageEvents && window.parent !== window.self ) {
                        window.parent.postMessage( JSON.stringify({ namespace: 'reveal', eventName: type, state: getState() }), '*' );
                }

        }

        /**
         * Wrap all links in 3D goodness.
         */
        function enableRollingLinks() {

                if( features.transforms3d && !( 'msPerspective' in document.body.style ) ) {
                        var anchors = dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' a' );

                        for( var i = 0, len = anchors.length; i < len; i++ ) {
                                var anchor = anchors[i];

                                if( anchor.textContent && !anchor.querySelector( '*' ) && ( !anchor.className || !anchor.classList.contains( anchor, 'roll' ) ) ) {
                                        var span = document.createElement('span');
                                        span.setAttribute('data-title', anchor.text);
                                        span.innerHTML = anchor.innerHTML;

                                        anchor.classList.add( 'roll' );
                                        anchor.innerHTML = '';
                                        anchor.appendChild(span);
                                }
                        }
                }

        }

        /**
         * Unwrap all 3D links.
         */
        function disableRollingLinks() {

                var anchors = dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ' a.roll' );

                for( var i = 0, len = anchors.length; i < len; i++ ) {
                        var anchor = anchors[i];
                        var span = anchor.querySelector( 'span' );

                        if( span ) {
                                anchor.classList.remove( 'roll' );
                                anchor.innerHTML = span.innerHTML;
                        }
                }

        }

        /**
         * Bind preview frame links.
         *
         * @param {string} [selector=a] - selector for anchors
         */
        function enablePreviewLinks( selector ) {

                var anchors = toArray( document.querySelectorAll( selector ? selector : 'a' ) );

                anchors.forEach( function( element ) {
                        if( /^(http|www)/gi.test( element.getAttribute( 'href' ) ) ) {
                                element.addEventListener( 'click', onPreviewLinkClicked, false );
                        }
                } );

        }

        /**
         * Unbind preview frame links.
         */
        function disablePreviewLinks( selector ) {

                var anchors = toArray( document.querySelectorAll( selector ? selector : 'a' ) );

                anchors.forEach( function( element ) {
                        if( /^(http|www)/gi.test( element.getAttribute( 'href' ) ) ) {
                                element.removeEventListener( 'click', onPreviewLinkClicked, false );
                        }
                } );

        }

        /**
         * Opens a preview window for the target URL.
         *
         * @param {string} url - url for preview iframe src
         */
        function showPreview( url ) {

                closeOverlay();

                dom.overlay = document.createElement( 'div' );
                dom.overlay.classList.add( 'overlay' );
                dom.overlay.classList.add( 'overlay-preview' );
                dom.wrapper.appendChild( dom.overlay );

                dom.overlay.innerHTML = [
                        '<header>',
                                '<a class="close" href="#"><span class="icon"></span></a>',
                                '<a class="external" href="'+ url +'" target="_blank"><span class="icon"></span></a>',
                        '</header>',
                        '<div class="spinner"></div>',
                        '<div class="viewport">',
                                '<iframe src="'+ url +'"></iframe>',
                                '<small class="viewport-inner">',
                                        '<span class="x-frame-error">Unable to load iframe. This is likely due to the site\'s policy (x-frame-options).</span>',
                                '</small>',
                        '</div>'
                ].join('');

                dom.overlay.querySelector( 'iframe' ).addEventListener( 'load', function( event ) {
                        dom.overlay.classList.add( 'loaded' );
                }, false );

                dom.overlay.querySelector( '.close' ).addEventListener( 'click', function( event ) {
                        closeOverlay();
                        event.preventDefault();
                }, false );

                dom.overlay.querySelector( '.external' ).addEventListener( 'click', function( event ) {
                        closeOverlay();
                }, false );

                setTimeout( function() {
                        dom.overlay.classList.add( 'visible' );
                }, 1 );

        }

        /**
         * Open or close help overlay window.
         *
         * @param {Boolean} [override] Flag which overrides the
         * toggle logic and forcibly sets the desired state. True means
         * help is open, false means it's closed.
         */
        function toggleHelp( override ){

                if( typeof override === 'boolean' ) {
                        override ? showHelp() : closeOverlay();
                }
                else {
                        if( dom.overlay ) {
                                closeOverlay();
                        }
                        else {
                                showHelp();
                        }
                }
        }

        /**
         * Opens an overlay window with help material.
         */
        function showHelp() {

                if( config.help ) {

                        closeOverlay();

                        dom.overlay = document.createElement( 'div' );
                        dom.overlay.classList.add( 'overlay' );
                        dom.overlay.classList.add( 'overlay-help' );
                        dom.wrapper.appendChild( dom.overlay );

                        var html = '<p class="title">Keyboard Shortcuts</p><br/>';

                        html += '<table><th>KEY</th><th>ACTION</th>';
                        for( var key in keyboardShortcuts ) {
                                html += '<tr><td>' + key + '</td><td>' + keyboardShortcuts[ key ] + '</td></tr>';
                        }

                        html += '</table>';

                        dom.overlay.innerHTML = [
                                '<header>',
                                        '<a class="close" href="#"><span class="icon"></span></a>',
                                '</header>',
                                '<div class="viewport">',
                                        '<div class="viewport-inner">'+ html +'</div>',
                                '</div>'
                        ].join('');

                        dom.overlay.querySelector( '.close' ).addEventListener( 'click', function( event ) {
                                closeOverlay();
                                event.preventDefault();
                        }, false );

                        setTimeout( function() {
                                dom.overlay.classList.add( 'visible' );
                        }, 1 );

                }

        }

        /**
         * Closes any currently open overlay.
         */
        function closeOverlay() {

                if( dom.overlay ) {
                        dom.overlay.parentNode.removeChild( dom.overlay );
                        dom.overlay = null;
                }

        }

        /**
         * Applies JavaScript-controlled layout rules to the
         * presentation.
         */
        function layout() {

                if( dom.wrapper && !isPrintingPDF() ) {

                        var size = getComputedSlideSize();

                        // Layout the contents of the slides
                        layoutSlideContents( config.width, config.height );

                        dom.slides.style.width = size.width + 'px';
                        dom.slides.style.height = size.height + 'px';

                        // Determine scale of content to fit within available space
                        scale = Math.min( size.presentationWidth / size.width, size.presentationHeight / size.height );

                        // Respect max/min scale settings
                        scale = Math.max( scale, config.minScale );
                        scale = Math.min( scale, config.maxScale );

                        // Don't apply any scaling styles if scale is 1
                        if( scale === 1 ) {
                                dom.slides.style.zoom = '';
                                dom.slides.style.left = '';
                                dom.slides.style.top = '';
                                dom.slides.style.bottom = '';
                                dom.slides.style.right = '';
                                transformSlides( { layout: '' } );
                        }
                        else {
                                // Prefer zoom for scaling up so that content remains crisp.
                                // Don't use zoom to scale down since that can lead to shifts
                                // in text layout/line breaks.
                                if( scale > 1 && features.zoom ) {
                                        dom.slides.style.zoom = scale;
                                        dom.slides.style.left = '';
                                        dom.slides.style.top = '';
                                        dom.slides.style.bottom = '';
                                        dom.slides.style.right = '';
                                        transformSlides( { layout: '' } );
                                }
                                // Apply scale transform as a fallback
                                else {
                                        dom.slides.style.zoom = '';
                                        dom.slides.style.left = '50%';
                                        dom.slides.style.top = '50%';
                                        dom.slides.style.bottom = 'auto';
                                        dom.slides.style.right = 'auto';
                                        transformSlides( { layout: 'translate(-50%, -50%) scale('+ scale +')' } );
                                }
                        }

                        // Select all slides, vertical and horizontal
                        var slides = toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) );

                        for( var i = 0, len = slides.length; i < len; i++ ) {
                                var slide = slides[ i ];

                                // Don't bother updating invisible slides
                                if( slide.style.display === 'none' ) {
                                        continue;
                                }

                                if( config.center || slide.classList.contains( 'center' ) ) {
                                        // Vertical stacks are not centred since their section
                                        // children will be
                                        if( slide.classList.contains( 'stack' ) ) {
                                                slide.style.top = 0;
                                        }
                                        else {
                                                slide.style.top = Math.max( ( size.height - slide.scrollHeight ) / 2, 0 ) + 'px';
                                        }
                                }
                                else {
                                        slide.style.top = '';
                                }

                        }

                        updateProgress();
                        updateParallax();

                        if( isOverview() ) {
                                updateOverview();
                        }

                }

        }

        /**
         * Applies layout logic to the contents of all slides in
         * the presentation.
         *
         * @param {string|number} width
         * @param {string|number} height
         */
        function layoutSlideContents( width, height ) {

                // Handle sizing of elements with the 'stretch' class
                toArray( dom.slides.querySelectorAll( 'section > .stretch' ) ).forEach( function( element ) {

                        // Determine how much vertical space we can use
                        var remainingHeight = getRemainingHeight( element, height );

                        // Consider the aspect ratio of media elements
                        if( /(img|video)/gi.test( element.nodeName ) ) {
                                var nw = element.naturalWidth || element.videoWidth,
                                        nh = element.naturalHeight || element.videoHeight;

                                var es = Math.min( width / nw, remainingHeight / nh );

                                element.style.width = ( nw * es ) + 'px';
                                element.style.height = ( nh * es ) + 'px';

                        }
                        else {
                                element.style.width = width + 'px';
                                element.style.height = remainingHeight + 'px';
                        }

                } );

        }

        /**
         * Calculates the computed pixel size of our slides. These
         * values are based on the width and height configuration
         * options.
         *
         * @param {number} [presentationWidth=dom.wrapper.offsetWidth]
         * @param {number} [presentationHeight=dom.wrapper.offsetHeight]
         */
        function getComputedSlideSize( presentationWidth, presentationHeight ) {

                var size = {
                        // Slide size
                        width: config.width,
                        height: config.height,

                        // Presentation size
                        presentationWidth: presentationWidth || dom.wrapper.offsetWidth,
                        presentationHeight: presentationHeight || dom.wrapper.offsetHeight
                };

                // Reduce available space by margin
                size.presentationWidth -= ( size.presentationWidth * config.margin );
                size.presentationHeight -= ( size.presentationHeight * config.margin );

                // Slide width may be a percentage of available width
                if( typeof size.width === 'string' && /%$/.test( size.width ) ) {
                        size.width = parseInt( size.width, 10 ) / 100 * size.presentationWidth;
                }

                // Slide height may be a percentage of available height
                if( typeof size.height === 'string' && /%$/.test( size.height ) ) {
                        size.height = parseInt( size.height, 10 ) / 100 * size.presentationHeight;
                }

                return size;

        }

        /**
         * Stores the vertical index of a stack so that the same
         * vertical slide can be selected when navigating to and
         * from the stack.
         *
         * @param {HTMLElement} stack The vertical stack element
         * @param {string|number} [v=0] Index to memorize
         */
        function setPreviousVerticalIndex( stack, v ) {

                if( typeof stack === 'object' && typeof stack.setAttribute === 'function' ) {
                        stack.setAttribute( 'data-previous-indexv', v || 0 );
                }

        }

        /**
         * Retrieves the vertical index which was stored using
         * #setPreviousVerticalIndex() or 0 if no previous index
         * exists.
         *
         * @param {HTMLElement} stack The vertical stack element
         */
        function getPreviousVerticalIndex( stack ) {

                if( typeof stack === 'object' && typeof stack.setAttribute === 'function' && stack.classList.contains( 'stack' ) ) {
                        // Prefer manually defined start-indexv
                        var attributeName = stack.hasAttribute( 'data-start-indexv' ) ? 'data-start-indexv' : 'data-previous-indexv';

                        return parseInt( stack.getAttribute( attributeName ) || 0, 10 );
                }

                return 0;

        }

        /**
         * Displays the overview of slides (quick nav) by scaling
         * down and arranging all slide elements.
         */
        function activateOverview() {

                // Only proceed if enabled in config
                if( config.overview && !isOverview() ) {

                        overview = true;

                        dom.wrapper.classList.add( 'overview' );
                        dom.wrapper.classList.remove( 'overview-deactivating' );

                        if( features.overviewTransitions ) {
                                setTimeout( function() {
                                        dom.wrapper.classList.add( 'overview-animated' );
                                }, 1 );
                        }

                        // Don't auto-slide while in overview mode
                        cancelAutoSlide();

                        // Move the backgrounds element into the slide container to
                        // that the same scaling is applied
                        dom.slides.appendChild( dom.background );

                        // Clicking on an overview slide navigates to it
                        toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {
                                if( !slide.classList.contains( 'stack' ) ) {
                                        slide.addEventListener( 'click', onOverviewSlideClicked, true );
                                }
                        } );

                        // Calculate slide sizes
                        var margin = 70;
                        var slideSize = getComputedSlideSize();
                        overviewSlideWidth = slideSize.width + margin;
                        overviewSlideHeight = slideSize.height + margin;

                        // Reverse in RTL mode
                        if( config.rtl ) {
                                overviewSlideWidth = -overviewSlideWidth;
                        }

                        updateSlidesVisibility();
                        layoutOverview();
                        updateOverview();

                        layout();

                        // Notify observers of the overview showing
                        dispatchEvent( 'overviewshown', {
                                'indexh': indexh,
                                'indexv': indexv,
                                'currentSlide': currentSlide
                        } );

                }

        }

        /**
         * Uses CSS transforms to position all slides in a grid for
         * display inside of the overview mode.
         */
        function layoutOverview() {

                // Layout slides
                toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).forEach( function( hslide, h ) {
                        hslide.setAttribute( 'data-index-h', h );
                        transformElement( hslide, 'translate3d(' + ( h * overviewSlideWidth ) + 'px, 0, 0)' );

                        if( hslide.classList.contains( 'stack' ) ) {

                                toArray( hslide.querySelectorAll( 'section' ) ).forEach( function( vslide, v ) {
                                        vslide.setAttribute( 'data-index-h', h );
                                        vslide.setAttribute( 'data-index-v', v );

                                        transformElement( vslide, 'translate3d(0, ' + ( v * overviewSlideHeight ) + 'px, 0)' );
                                } );

                        }
                } );

                // Layout slide backgrounds
                toArray( dom.background.childNodes ).forEach( function( hbackground, h ) {
                        transformElement( hbackground, 'translate3d(' + ( h * overviewSlideWidth ) + 'px, 0, 0)' );

                        toArray( hbackground.querySelectorAll( '.slide-background' ) ).forEach( function( vbackground, v ) {
                                transformElement( vbackground, 'translate3d(0, ' + ( v * overviewSlideHeight ) + 'px, 0)' );
                        } );
                } );

        }

        /**
         * Moves the overview viewport to the current slides.
         * Called each time the current slide changes.
         */
        function updateOverview() {

                var vmin = Math.min( window.innerWidth, window.innerHeight );
                var scale = Math.max( vmin / 5, 150 ) / vmin;

                transformSlides( {
                        overview: [
                                'scale('+ scale +')',
                                'translateX('+ ( -indexh * overviewSlideWidth ) +'px)',
                                'translateY('+ ( -indexv * overviewSlideHeight ) +'px)'
                        ].join( ' ' )
                } );

        }

        /**
         * Exits the slide overview and enters the currently
         * active slide.
         */
        function deactivateOverview() {

                // Only proceed if enabled in config
                if( config.overview ) {

                        overview = false;

                        dom.wrapper.classList.remove( 'overview' );
                        dom.wrapper.classList.remove( 'overview-animated' );

                        // Temporarily add a class so that transitions can do different things
                        // depending on whether they are exiting/entering overview, or just
                        // moving from slide to slide
                        dom.wrapper.classList.add( 'overview-deactivating' );

                        setTimeout( function () {
                                dom.wrapper.classList.remove( 'overview-deactivating' );
                        }, 1 );

                        // Move the background element back out
                        dom.wrapper.appendChild( dom.background );

                        // Clean up changes made to slides
                        toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) ).forEach( function( slide ) {
                                transformElement( slide, '' );

                                slide.removeEventListener( 'click', onOverviewSlideClicked, true );
                        } );

                        // Clean up changes made to backgrounds
                        toArray( dom.background.querySelectorAll( '.slide-background' ) ).forEach( function( background ) {
                                transformElement( background, '' );
                        } );

                        transformSlides( { overview: '' } );

                        slide( indexh, indexv );

                        layout();

                        cueAutoSlide();

                        // Notify observers of the overview hiding
                        dispatchEvent( 'overviewhidden', {
                                'indexh': indexh,
                                'indexv': indexv,
                                'currentSlide': currentSlide
                        } );

                }
        }

        /**
         * Toggles the slide overview mode on and off.
         *
         * @param {Boolean} [override] Flag which overrides the
         * toggle logic and forcibly sets the desired state. True means
         * overview is open, false means it's closed.
         */
        function toggleOverview( override ) {

                if( typeof override === 'boolean' ) {
                        override ? activateOverview() : deactivateOverview();
                }
                else {
                        isOverview() ? deactivateOverview() : activateOverview();
                }

        }

        /**
         * Checks if the overview is currently active.
         *
         * @return {Boolean} true if the overview is active,
         * false otherwise
         */
        function isOverview() {

                return overview;

        }

        /**
         * Checks if the current or specified slide is vertical
         * (nested within another slide).
         *
         * @param {HTMLElement} [slide=currentSlide] The slide to check
         * orientation of
         * @return {Boolean}
         */
        function isVerticalSlide( slide ) {

                // Prefer slide argument, otherwise use current slide
                slide = slide ? slide : currentSlide;

                return slide && slide.parentNode && !!slide.parentNode.nodeName.match( /section/i );

        }

        /**
         * Handling the fullscreen functionality via the fullscreen API
         *
         * @see http://fullscreen.spec.whatwg.org/
         * @see https://developer.mozilla.org/en-US/docs/DOM/Using_fullscreen_mode
         */
        function enterFullscreen() {

                var element = document.documentElement;

                // Check which implementation is available
                var requestMethod = element.requestFullscreen ||
                                                        element.webkitRequestFullscreen ||
                                                        element.webkitRequestFullScreen ||
                                                        element.mozRequestFullScreen ||
                                                        element.msRequestFullscreen;

                if( requestMethod ) {
                        requestMethod.apply( element );
                }

        }

        /**
         * Enters the paused mode which fades everything on screen to
         * black.
         */
        function pause() {

                if( config.pause ) {
                        var wasPaused = dom.wrapper.classList.contains( 'paused' );

                        cancelAutoSlide();
                        dom.wrapper.classList.add( 'paused' );

                        if( wasPaused === false ) {
                                dispatchEvent( 'paused' );
                        }
                }

        }

        /**
         * Exits from the paused mode.
         */
        function resume() {

                var wasPaused = dom.wrapper.classList.contains( 'paused' );
                dom.wrapper.classList.remove( 'paused' );

                cueAutoSlide();

                if( wasPaused ) {
                        dispatchEvent( 'resumed' );
                }

        }

        /**
         * Toggles the paused mode on and off.
         */
        function togglePause( override ) {

                if( typeof override === 'boolean' ) {
                        override ? pause() : resume();
                }
                else {
                        isPaused() ? resume() : pause();
                }

        }

        /**
         * Checks if we are currently in the paused mode.
         *
         * @return {Boolean}
         */
        function isPaused() {

                return dom.wrapper.classList.contains( 'paused' );

        }

        /**
         * Toggles the auto slide mode on and off.
         *
         * @param {Boolean} [override] Flag which sets the desired state.
         * True means autoplay starts, false means it stops.
         */

        function toggleAutoSlide( override ) {

                if( typeof override === 'boolean' ) {
                        override ? resumeAutoSlide() : pauseAutoSlide();
                }

                else {
                        autoSlidePaused ? resumeAutoSlide() : pauseAutoSlide();
                }

        }

        /**
         * Checks if the auto slide mode is currently on.
         *
         * @return {Boolean}
         */
        function isAutoSliding() {

                return !!( autoSlide && !autoSlidePaused );

        }

        /**
         * Steps from the current point in the presentation to the
         * slide which matches the specified horizontal and vertical
         * indices.
         *
         * @param {number} [h=indexh] Horizontal index of the target slide
         * @param {number} [v=indexv] Vertical index of the target slide
         * @param {number} [f] Index of a fragment within the
         * target slide to activate
         * @param {number} [o] Origin for use in multimaster environments
         */
        function slide( h, v, f, o ) {

                // Remember where we were at before
                previousSlide = currentSlide;

                // Query all horizontal slides in the deck
                var horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );

                // Abort if there are no slides
                if( horizontalSlides.length === 0 ) return;

                // If no vertical index is specified and the upcoming slide is a
                // stack, resume at its previous vertical index
                if( v === undefined && !isOverview() ) {
                        v = getPreviousVerticalIndex( horizontalSlides[ h ] );
                }

                // If we were on a vertical stack, remember what vertical index
                // it was on so we can resume at the same position when returning
                if( previousSlide && previousSlide.parentNode && previousSlide.parentNode.classList.contains( 'stack' ) ) {
                        setPreviousVerticalIndex( previousSlide.parentNode, indexv );
                }

                // Remember the state before this slide
                var stateBefore = state.concat();

                // Reset the state array
                state.length = 0;

                var indexhBefore = indexh || 0,
                        indexvBefore = indexv || 0;

                // Activate and transition to the new slide
                indexh = updateSlides( HORIZONTAL_SLIDES_SELECTOR, h === undefined ? indexh : h );
                indexv = updateSlides( VERTICAL_SLIDES_SELECTOR, v === undefined ? indexv : v );

                // Update the visibility of slides now that the indices have changed
                updateSlidesVisibility();

                layout();

                // Apply the new state
                stateLoop: for( var i = 0, len = state.length; i < len; i++ ) {
                        // Check if this state existed on the previous slide. If it
                        // did, we will avoid adding it repeatedly
                        for( var j = 0; j < stateBefore.length; j++ ) {
                                if( stateBefore[j] === state[i] ) {
                                        stateBefore.splice( j, 1 );
                                        continue stateLoop;
                                }
                        }

                        document.documentElement.classList.add( state[i] );

                        // Dispatch custom event matching the state's name
                        dispatchEvent( state[i] );
                }

                // Clean up the remains of the previous state
                while( stateBefore.length ) {
                        document.documentElement.classList.remove( stateBefore.pop() );
                }

                // Update the overview if it's currently active
                if( isOverview() ) {
                        updateOverview();
                }

                // Find the current horizontal slide and any possible vertical slides
                // within it
                var currentHorizontalSlide = horizontalSlides[ indexh ],
                        currentVerticalSlides = currentHorizontalSlide.querySelectorAll( 'section' );

                // Store references to the previous and current slides
                currentSlide = currentVerticalSlides[ indexv ] || currentHorizontalSlide;

                // Show fragment, if specified
                if( typeof f !== 'undefined' ) {
                        navigateFragment( f );
                }

                // Dispatch an event if the slide changed
                var slideChanged = ( indexh !== indexhBefore || indexv !== indexvBefore );
                if( slideChanged ) {
                        dispatchEvent( 'slidechanged', {
                                'indexh': indexh,
                                'indexv': indexv,
                                'previousSlide': previousSlide,
                                'currentSlide': currentSlide,
                                'origin': o
                        } );
                }
                else {
                        // Ensure that the previous slide is never the same as the current
                        previousSlide = null;
                }

                // Solves an edge case where the previous slide maintains the
                // 'present' class when navigating between adjacent vertical
                // stacks
                if( previousSlide ) {
                        previousSlide.classList.remove( 'present' );
                        previousSlide.setAttribute( 'aria-hidden', 'true' );

                        // Reset all slides upon navigate to home
                        // Issue: #285
                        if ( dom.wrapper.querySelector( HOME_SLIDE_SELECTOR ).classList.contains( 'present' ) ) {
                                // Launch async task
                                setTimeout( function () {
                                        var slides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.stack') ), i;
                                        for( i in slides ) {
                                                if( slides[i] ) {
                                                        // Reset stack
                                                        setPreviousVerticalIndex( slides[i], 0 );
                                                }
                                        }
                                }, 0 );
                        }
                }

                // Handle embedded content
                if( slideChanged || !previousSlide ) {
                        stopEmbeddedContent( previousSlide );
                        startEmbeddedContent( currentSlide );
                }

                // Announce the current slide contents, for screen readers
                dom.statusDiv.textContent = getStatusText( currentSlide );

                updateControls();
                updateProgress();
                updateBackground();
                updateParallax();
                updateSlideNumber();
                updateNotes();

                // Update the URL hash
                writeURL();

                cueAutoSlide();

        }

        /**
         * Syncs the presentation with the current DOM. Useful
         * when new slides or control elements are added or when
         * the configuration has changed.
         */
        function sync() {

                // Subscribe to input
                removeEventListeners();
                addEventListeners();

                // Force a layout to make sure the current config is accounted for
                layout();

                // Reflect the current autoSlide value
                autoSlide = config.autoSlide;

                // Start auto-sliding if it's enabled
                cueAutoSlide();

                // Re-create the slide backgrounds
                createBackgrounds();

                // Write the current hash to the URL
                writeURL();

                sortAllFragments();

                updateControls();
                updateProgress();
                updateSlideNumber();
                updateSlidesVisibility();
                updateBackground( true );
                updateNotesVisibility();
                updateNotes();

                formatEmbeddedContent();

                // Start or stop embedded content depending on global config
                if( config.autoPlayMedia === false ) {
                        stopEmbeddedContent( currentSlide, { unloadIframes: false } );
                }
                else {
                        startEmbeddedContent( currentSlide );
                }

                if( isOverview() ) {
                        layoutOverview();
                }

        }

        /**
         * Resets all vertical slides so that only the first
         * is visible.
         */
        function resetVerticalSlides() {

                var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );
                horizontalSlides.forEach( function( horizontalSlide ) {

                        var verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );
                        verticalSlides.forEach( function( verticalSlide, y ) {

                                if( y > 0 ) {
                                        verticalSlide.classList.remove( 'present' );
                                        verticalSlide.classList.remove( 'past' );
                                        verticalSlide.classList.add( 'future' );
                                        verticalSlide.setAttribute( 'aria-hidden', 'true' );
                                }

                        } );

                } );

        }

        /**
         * Sorts and formats all of fragments in the
         * presentation.
         */
        function sortAllFragments() {

                var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );
                horizontalSlides.forEach( function( horizontalSlide ) {

                        var verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );
                        verticalSlides.forEach( function( verticalSlide, y ) {

                                sortFragments( verticalSlide.querySelectorAll( '.fragment' ) );

                        } );

                        if( verticalSlides.length === 0 ) sortFragments( horizontalSlide.querySelectorAll( '.fragment' ) );

                } );

        }

        /**
         * Randomly shuffles all slides in the deck.
         */
        function shuffle() {

                var slides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );

                slides.forEach( function( slide ) {

                        // Insert this slide next to another random slide. This may
                        // cause the slide to insert before itself but that's fine.
                        dom.slides.insertBefore( slide, slides[ Math.floor( Math.random() * slides.length ) ] );

                } );

        }

        /**
         * Updates one dimension of slides by showing the slide
         * with the specified index.
         *
         * @param {string} selector A CSS selector that will fetch
         * the group of slides we are working with
         * @param {number} index The index of the slide that should be
         * shown
         *
         * @return {number} The index of the slide that is now shown,
         * might differ from the passed in index if it was out of
         * bounds.
         */
        function updateSlides( selector, index ) {

                // Select all slides and convert the NodeList result to
                // an array
                var slides = toArray( dom.wrapper.querySelectorAll( selector ) ),
                        slidesLength = slides.length;

                var printMode = isPrintingPDF();

                if( slidesLength ) {

                        // Should the index loop?
                        if( config.loop ) {
                                index %= slidesLength;

                                if( index < 0 ) {
                                        index = slidesLength + index;
                                }
                        }

                        // Enforce max and minimum index bounds
                        index = Math.max( Math.min( index, slidesLength - 1 ), 0 );

                        for( var i = 0; i < slidesLength; i++ ) {
                                var element = slides[i];

                                var reverse = config.rtl && !isVerticalSlide( element );

                                element.classList.remove( 'past' );
                                element.classList.remove( 'present' );
                                element.classList.remove( 'future' );

                                // http://www.w3.org/html/wg/drafts/html/master/editing.html#the-hidden-attribute
                                element.setAttribute( 'hidden', '' );
                                element.setAttribute( 'aria-hidden', 'true' );

                                // If this element contains vertical slides
                                if( element.querySelector( 'section' ) ) {
                                        element.classList.add( 'stack' );
                                }

                                // If we're printing static slides, all slides are "present"
                                if( printMode ) {
                                        element.classList.add( 'present' );
                                        continue;
                                }

                                if( i < index ) {
                                        // Any element previous to index is given the 'past' class
                                        element.classList.add( reverse ? 'future' : 'past' );

                                        if( config.fragments ) {
                                                var pastFragments = toArray( element.querySelectorAll( '.fragment' ) );

                                                // Show all fragments on prior slides
                                                while( pastFragments.length ) {
                                                        var pastFragment = pastFragments.pop();
                                                        pastFragment.classList.add( 'visible' );
                                                        pastFragment.classList.remove( 'current-fragment' );
                                                }
                                        }
                                }
                                else if( i > index ) {
                                        // Any element subsequent to index is given the 'future' class
                                        element.classList.add( reverse ? 'past' : 'future' );

                                        if( config.fragments ) {
                                                var futureFragments = toArray( element.querySelectorAll( '.fragment.visible' ) );

                                                // No fragments in future slides should be visible ahead of time
                                                while( futureFragments.length ) {
                                                        var futureFragment = futureFragments.pop();
                                                        futureFragment.classList.remove( 'visible' );
                                                        futureFragment.classList.remove( 'current-fragment' );
                                                }
                                        }
                                }
                        }

                        // Mark the current slide as present
                        slides[index].classList.add( 'present' );
                        slides[index].removeAttribute( 'hidden' );
                        slides[index].removeAttribute( 'aria-hidden' );

                        // If this slide has a state associated with it, add it
                        // onto the current state of the deck
                        var slideState = slides[index].getAttribute( 'data-state' );
                        if( slideState ) {
                                state = state.concat( slideState.split( ' ' ) );
                        }

                }
                else {
                        // Since there are no slides we can't be anywhere beyond the
                        // zeroth index
                        index = 0;
                }

                return index;

        }

        /**
         * Optimization method; hide all slides that are far away
         * from the present slide.
         */
        function updateSlidesVisibility() {

                // Select all slides and convert the NodeList result to
                // an array
                var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ),
                        horizontalSlidesLength = horizontalSlides.length,
                        distanceX,
                        distanceY;

                if( horizontalSlidesLength && typeof indexh !== 'undefined' ) {

                        // The number of steps away from the present slide that will
                        // be visible
                        var viewDistance = isOverview() ? 10 : config.viewDistance;

                        // Limit view distance on weaker devices
                        if( isMobileDevice ) {
                                viewDistance = isOverview() ? 6 : 2;
                        }

                        // All slides need to be visible when exporting to PDF
                        if( isPrintingPDF() ) {
                                viewDistance = Number.MAX_VALUE;
                        }

                        for( var x = 0; x < horizontalSlidesLength; x++ ) {
                                var horizontalSlide = horizontalSlides[x];

                                var verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) ),
                                        verticalSlidesLength = verticalSlides.length;

                                // Determine how far away this slide is from the present
                                distanceX = Math.abs( ( indexh || 0 ) - x ) || 0;

                                // If the presentation is looped, distance should measure
                                // 1 between the first and last slides
                                if( config.loop ) {
                                        distanceX = Math.abs( ( ( indexh || 0 ) - x ) % ( horizontalSlidesLength - viewDistance ) ) || 0;
                                }

                                // Show the horizontal slide if it's within the view distance
                                if( distanceX < viewDistance ) {
                                        loadSlide( horizontalSlide );
                                }
                                else {
                                        unloadSlide( horizontalSlide );
                                }

                                if( verticalSlidesLength ) {

                                        var oy = getPreviousVerticalIndex( horizontalSlide );

                                        for( var y = 0; y < verticalSlidesLength; y++ ) {
                                                var verticalSlide = verticalSlides[y];

                                                distanceY = x === ( indexh || 0 ) ? Math.abs( ( indexv || 0 ) - y ) : Math.abs( y - oy );

                                                if( distanceX + distanceY < viewDistance ) {
                                                        loadSlide( verticalSlide );
                                                }
                                                else {
                                                        unloadSlide( verticalSlide );
                                                }
                                        }

                                }
                        }

                        // Flag if there are ANY vertical slides, anywhere in the deck
                        if( dom.wrapper.querySelectorAll( '.slides>section>section' ).length ) {
                                dom.wrapper.classList.add( 'has-vertical-slides' );
                        }
                        else {
                                dom.wrapper.classList.remove( 'has-vertical-slides' );
                        }

                        // Flag if there are ANY horizontal slides, anywhere in the deck
                        if( dom.wrapper.querySelectorAll( '.slides>section' ).length > 1 ) {
                                dom.wrapper.classList.add( 'has-horizontal-slides' );
                        }
                        else {
                                dom.wrapper.classList.remove( 'has-horizontal-slides' );
                        }

                }

        }

        /**
         * Pick up notes from the current slide and display them
         * to the viewer.
         *
         * @see {@link config.showNotes}
         */
        function updateNotes() {

                if( config.showNotes && dom.speakerNotes && currentSlide && !isPrintingPDF() ) {

                        dom.speakerNotes.innerHTML = getSlideNotes() || '<span class="notes-placeholder">No notes on this slide.</span>';

                }

        }

        /**
         * Updates the visibility of the speaker notes sidebar that
         * is used to share annotated slides. The notes sidebar is
         * only visible if showNotes is true and there are notes on
         * one or more slides in the deck.
         */
        function updateNotesVisibility() {

                if( config.showNotes && hasNotes() ) {
                        dom.wrapper.classList.add( 'show-notes' );
                }
                else {
                        dom.wrapper.classList.remove( 'show-notes' );
                }

        }

        /**
         * Checks if there are speaker notes for ANY slide in the
         * presentation.
         */
        function hasNotes() {

                return dom.slides.querySelectorAll( '[data-notes], aside.notes' ).length > 0;

        }

        /**
         * Updates the progress bar to reflect the current slide.
         */
        function updateProgress() {

                // Update progress if enabled
                if( config.progress && dom.progressbar ) {

                        dom.progressbar.style.width = getProgress() * dom.wrapper.offsetWidth + 'px';

                }

        }

        /**
         * Updates the slide number div to reflect the current slide.
         *
         * The following slide number formats are available:
         *  "h.v":	horizontal . vertical slide number (default)
         *  "h/v":	horizontal / vertical slide number
         *    "c":	flattened slide number
         *  "c/t":	flattened slide number / total slides
         */
        function updateSlideNumber() {

                // Update slide number if enabled
                if( config.slideNumber && dom.slideNumber ) {

                        var value = [];
                        var format = 'h.v';

                        // Check if a custom number format is available
                        if( typeof config.slideNumber === 'string' ) {
                                format = config.slideNumber;
                        }

                        switch( format ) {
                                case 'c':
                                        value.push( getSlidePastCount() + 1 );
                                        break;
                                case 'c/t':
                                        value.push( getSlidePastCount() + 1, '/', getTotalSlides() );
                                        break;
                                case 'h/v':
                                        value.push( indexh + 1 );
                                        if( isVerticalSlide() ) value.push( '/', indexv + 1 );
                                        break;
                                default:
                                        value.push( indexh + 1 );
                                        if( isVerticalSlide() ) value.push( '.', indexv + 1 );
                        }

                        dom.slideNumber.innerHTML = formatSlideNumber( value[0], value[1], value[2] );
                }

        }

        /**
         * Applies HTML formatting to a slide number before it's
         * written to the DOM.
         *
         * @param {number} a Current slide
         * @param {string} delimiter Character to separate slide numbers
         * @param {(number|*)} b Total slides
         * @return {string} HTML string fragment
         */
        function formatSlideNumber( a, delimiter, b ) {

                if( typeof b === 'number' && !isNaN( b ) ) {
                        return  '<span class="slide-number-a">'+ a +'</span>' +
                                        '<span class="slide-number-delimiter">'+ delimiter +'</span>' +
                                        '<span class="slide-number-b">'+ b +'</span>';
                }
                else {
                        return '<span class="slide-number-a">'+ a +'</span>';
                }

        }

        /**
         * Updates the state of all control/navigation arrows.
         */
        function updateControls() {

                var routes = availableRoutes();
                var fragments = availableFragments();

                // Remove the 'enabled' class from all directions
                dom.controlsLeft.concat( dom.controlsRight )
                                                .concat( dom.controlsUp )
                                                .concat( dom.controlsDown )
                                                .concat( dom.controlsPrev )
                                                .concat( dom.controlsNext ).forEach( function( node ) {
                        node.classList.remove( 'enabled' );
                        node.classList.remove( 'fragmented' );

                        // Set 'disabled' attribute on all directions
                        node.setAttribute( 'disabled', 'disabled' );
                } );

                // Add the 'enabled' class to the available routes; remove 'disabled' attribute to enable buttons
                if( routes.left ) dom.controlsLeft.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );
                if( routes.right ) dom.controlsRight.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );
                if( routes.up ) dom.controlsUp.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );
                if( routes.down ) dom.controlsDown.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );

                // Prev/next buttons
                if( routes.left || routes.up ) dom.controlsPrev.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );
                if( routes.right || routes.down ) dom.controlsNext.forEach( function( el ) { el.classList.add( 'enabled' ); el.removeAttribute( 'disabled' ); } );

                // Highlight fragment directions
                if( currentSlide ) {

                        // Always apply fragment decorator to prev/next buttons
                        if( fragments.prev ) dom.controlsPrev.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );
                        if( fragments.next ) dom.controlsNext.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );

                        // Apply fragment decorators to directional buttons based on
                        // what slide axis they are in
                        if( isVerticalSlide( currentSlide ) ) {
                                if( fragments.prev ) dom.controlsUp.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );
                                if( fragments.next ) dom.controlsDown.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );
                        }
                        else {
                                if( fragments.prev ) dom.controlsLeft.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );
                                if( fragments.next ) dom.controlsRight.forEach( function( el ) { el.classList.add( 'fragmented', 'enabled' ); el.removeAttribute( 'disabled' ); } );
                        }

                }

                if( config.controlsTutorial ) {

                        // Highlight control arrows with an animation to ensure
                        // that the viewer knows how to navigate
                        if( !hasNavigatedDown && routes.down ) {
                                dom.controlsDownArrow.classList.add( 'highlight' );
                        }
                        else {
                                dom.controlsDownArrow.classList.remove( 'highlight' );

                                if( !hasNavigatedRight && routes.right && indexv === 0 ) {
                                        dom.controlsRightArrow.classList.add( 'highlight' );
                                }
                                else {
                                        dom.controlsRightArrow.classList.remove( 'highlight' );
                                }
                        }

                }

        }

        /**
         * Updates the background elements to reflect the current
         * slide.
         *
         * @param {boolean} includeAll If true, the backgrounds of
         * all vertical slides (not just the present) will be updated.
         */
        function updateBackground( includeAll ) {

                var currentBackground = null;

                // Reverse past/future classes when in RTL mode
                var horizontalPast = config.rtl ? 'future' : 'past',
                        horizontalFuture = config.rtl ? 'past' : 'future';

                // Update the classes of all backgrounds to match the
                // states of their slides (past/present/future)
                toArray( dom.background.childNodes ).forEach( function( backgroundh, h ) {

                        backgroundh.classList.remove( 'past' );
                        backgroundh.classList.remove( 'present' );
                        backgroundh.classList.remove( 'future' );

                        if( h < indexh ) {
                                backgroundh.classList.add( horizontalPast );
                        }
                        else if ( h > indexh ) {
                                backgroundh.classList.add( horizontalFuture );
                        }
                        else {
                                backgroundh.classList.add( 'present' );

                                // Store a reference to the current background element
                                currentBackground = backgroundh;
                        }

                        if( includeAll || h === indexh ) {
                                toArray( backgroundh.querySelectorAll( '.slide-background' ) ).forEach( function( backgroundv, v ) {

                                        backgroundv.classList.remove( 'past' );
                                        backgroundv.classList.remove( 'present' );
                                        backgroundv.classList.remove( 'future' );

                                        if( v < indexv ) {
                                                backgroundv.classList.add( 'past' );
                                        }
                                        else if ( v > indexv ) {
                                                backgroundv.classList.add( 'future' );
                                        }
                                        else {
                                                backgroundv.classList.add( 'present' );

                                                // Only if this is the present horizontal and vertical slide
                                                if( h === indexh ) currentBackground = backgroundv;
                                        }

                                } );
                        }

                } );

                // Stop content inside of previous backgrounds
                if( previousBackground ) {

                        stopEmbeddedContent( previousBackground );

                }

                // Start content in the current background
                if( currentBackground ) {

                        startEmbeddedContent( currentBackground );

                        var backgroundImageURL = currentBackground.style.backgroundImage || '';

                        // Restart GIFs (doesn't work in Firefox)
                        if( /\.gif/i.test( backgroundImageURL ) ) {
                                currentBackground.style.backgroundImage = '';
                                window.getComputedStyle( currentBackground ).opacity;
                                currentBackground.style.backgroundImage = backgroundImageURL;
                        }

                        // Don't transition between identical backgrounds. This
                        // prevents unwanted flicker.
                        var previousBackgroundHash = previousBackground ? previousBackground.getAttribute( 'data-background-hash' ) : null;
                        var currentBackgroundHash = currentBackground.getAttribute( 'data-background-hash' );
                        if( currentBackgroundHash && currentBackgroundHash === previousBackgroundHash && currentBackground !== previousBackground ) {
                                dom.background.classList.add( 'no-transition' );
                        }

                        previousBackground = currentBackground;

                }

                // If there's a background brightness flag for this slide,
                // bubble it to the .reveal container
                if( currentSlide ) {
                        [ 'has-light-background', 'has-dark-background' ].forEach( function( classToBubble ) {
                                if( currentSlide.classList.contains( classToBubble ) ) {
                                        dom.wrapper.classList.add( classToBubble );
                                }
                                else {
                                        dom.wrapper.classList.remove( classToBubble );
                                }
                        } );
                }

                // Allow the first background to apply without transition
                setTimeout( function() {
                        dom.background.classList.remove( 'no-transition' );
                }, 1 );

        }

        /**
         * Updates the position of the parallax background based
         * on the current slide index.
         */
        function updateParallax() {

                if( config.parallaxBackgroundImage ) {

                        var horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),
                                verticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );

                        var backgroundSize = dom.background.style.backgroundSize.split( ' ' ),
                                backgroundWidth, backgroundHeight;

                        if( backgroundSize.length === 1 ) {
                                backgroundWidth = backgroundHeight = parseInt( backgroundSize[0], 10 );
                        }
                        else {
                                backgroundWidth = parseInt( backgroundSize[0], 10 );
                                backgroundHeight = parseInt( backgroundSize[1], 10 );
                        }

                        var slideWidth = dom.background.offsetWidth,
                                horizontalSlideCount = horizontalSlides.length,
                                horizontalOffsetMultiplier,
                                horizontalOffset;

                        if( typeof config.parallaxBackgroundHorizontal === 'number' ) {
                                horizontalOffsetMultiplier = config.parallaxBackgroundHorizontal;
                        }
                        else {
                                horizontalOffsetMultiplier = horizontalSlideCount > 1 ? ( backgroundWidth - slideWidth ) / ( horizontalSlideCount-1 ) : 0;
                        }

                        horizontalOffset = horizontalOffsetMultiplier * indexh * -1;

                        var slideHeight = dom.background.offsetHeight,
                                verticalSlideCount = verticalSlides.length,
                                verticalOffsetMultiplier,
                                verticalOffset;

                        if( typeof config.parallaxBackgroundVertical === 'number' ) {
                                verticalOffsetMultiplier = config.parallaxBackgroundVertical;
                        }
                        else {
                                verticalOffsetMultiplier = ( backgroundHeight - slideHeight ) / ( verticalSlideCount-1 );
                        }

                        verticalOffset = verticalSlideCount > 0 ?  verticalOffsetMultiplier * indexv : 0;

                        dom.background.style.backgroundPosition = horizontalOffset + 'px ' + -verticalOffset + 'px';

                }

        }

        /**
         * Called when the given slide is within the configured view
         * distance. Shows the slide element and loads any content
         * that is set to load lazily (data-src).
         *
         * @param {HTMLElement} slide Slide to show
         */
        function loadSlide( slide, options ) {

                options = options || {};

                // Show the slide element
                slide.style.display = config.display;

                // Media elements with data-src attributes
                toArray( slide.querySelectorAll( 'img[data-src], video[data-src], audio[data-src]' ) ).forEach( function( element ) {
                        element.setAttribute( 'src', element.getAttribute( 'data-src' ) );
                        element.setAttribute( 'data-lazy-loaded', '' );
                        element.removeAttribute( 'data-src' );
                } );

                // Media elements with <source> children
                toArray( slide.querySelectorAll( 'video, audio' ) ).forEach( function( media ) {
                        var sources = 0;

                        toArray( media.querySelectorAll( 'source[data-src]' ) ).forEach( function( source ) {
                                source.setAttribute( 'src', source.getAttribute( 'data-src' ) );
                                source.removeAttribute( 'data-src' );
                                source.setAttribute( 'data-lazy-loaded', '' );
                                sources += 1;
                        } );

                        // If we rewrote sources for this video/audio element, we need
                        // to manually tell it to load from its new origin
                        if( sources > 0 ) {
                                media.load();
                        }
                } );


                // Show the corresponding background element
                var indices = getIndices( slide );
                var background = getSlideBackground( indices.h, indices.v );
                if( background ) {
                        background.style.display = 'block';

                        // If the background contains media, load it
                        if( background.hasAttribute( 'data-loaded' ) === false ) {
                                background.setAttribute( 'data-loaded', 'true' );

                                var backgroundImage = slide.getAttribute( 'data-background-image' ),
                                        backgroundVideo = slide.getAttribute( 'data-background-video' ),
                                        backgroundVideoLoop = slide.hasAttribute( 'data-background-video-loop' ),
                                        backgroundVideoMuted = slide.hasAttribute( 'data-background-video-muted' ),
                                        backgroundIframe = slide.getAttribute( 'data-background-iframe' );

                                // Images
                                if( backgroundImage ) {
                                        background.style.backgroundImage = 'url('+ backgroundImage +')';
                                }
                                // Videos
                                else if ( backgroundVideo && !isSpeakerNotes() ) {
                                        var video = document.createElement( 'video' );

                                        if( backgroundVideoLoop ) {
                                                video.setAttribute( 'loop', '' );
                                        }

                                        if( backgroundVideoMuted ) {
                                                video.muted = true;
                                        }

                                        // Inline video playback works (at least in Mobile Safari) as
                                        // long as the video is muted and the `playsinline` attribute is
                                        // present
                                        if( isMobileDevice ) {
                                                video.muted = true;
                                                video.autoplay = true;
                                                video.setAttribute( 'playsinline', '' );
                                        }

                                        // Support comma separated lists of video sources
                                        backgroundVideo.split( ',' ).forEach( function( source ) {
                                                video.innerHTML += '<source src="'+ source +'">';
                                        } );

                                        background.appendChild( video );
                                }
                                // Iframes
                                else if( backgroundIframe && options.excludeIframes !== true ) {
                                        var iframe = document.createElement( 'iframe' );
                                        iframe.setAttribute( 'allowfullscreen', '' );
                                        iframe.setAttribute( 'mozallowfullscreen', '' );
                                        iframe.setAttribute( 'webkitallowfullscreen', '' );

                                        // Only load autoplaying content when the slide is shown to
                                        // avoid having it play in the background
                                        if( /autoplay=(1|true|yes)/gi.test( backgroundIframe ) ) {
                                                iframe.setAttribute( 'data-src', backgroundIframe );
                                        }
                                        else {
                                                iframe.setAttribute( 'src', backgroundIframe );
                                        }

                                        iframe.style.width  = '100%';
                                        iframe.style.height = '100%';
                                        iframe.style.maxHeight = '100%';
                                        iframe.style.maxWidth = '100%';

                                        background.appendChild( iframe );
                                }
                        }

                }

        }

        /**
         * Unloads and hides the given slide. This is called when the
         * slide is moved outside of the configured view distance.
         *
         * @param {HTMLElement} slide
         */
        function unloadSlide( slide ) {

                // Hide the slide element
                slide.style.display = 'none';

                // Hide the corresponding background element
                var indices = getIndices( slide );
                var background = getSlideBackground( indices.h, indices.v );
                if( background ) {
                        background.style.display = 'none';
                }

                // Reset lazy-loaded media elements with src attributes
                toArray( slide.querySelectorAll( 'video[data-lazy-loaded][src], audio[data-lazy-loaded][src]' ) ).forEach( function( element ) {
                        element.setAttribute( 'data-src', element.getAttribute( 'src' ) );
                        element.removeAttribute( 'src' );
                } );

                // Reset lazy-loaded media elements with <source> children
                toArray( slide.querySelectorAll( 'video[data-lazy-loaded] source[src], audio source[src]' ) ).forEach( function( source ) {
                        source.setAttribute( 'data-src', source.getAttribute( 'src' ) );
                        source.removeAttribute( 'src' );
                } );

        }

        /**
         * Determine what available routes there are for navigation.
         *
         * @return {{left: boolean, right: boolean, up: boolean, down: boolean}}
         */
        function availableRoutes() {

                var horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),
                        verticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );

                var routes = {
                        left: indexh > 0 || config.loop,
                        right: indexh < horizontalSlides.length - 1 || config.loop,
                        up: indexv > 0,
                        down: indexv < verticalSlides.length - 1
                };

                // reverse horizontal controls for rtl
                if( config.rtl ) {
                        var left = routes.left;
                        routes.left = routes.right;
                        routes.right = left;
                }

                return routes;

        }

        /**
         * Returns an object describing the available fragment
         * directions.
         *
         * @return {{prev: boolean, next: boolean}}
         */
        function availableFragments() {

                if( currentSlide && config.fragments ) {
                        var fragments = currentSlide.querySelectorAll( '.fragment' );
                        var hiddenFragments = currentSlide.querySelectorAll( '.fragment:not(.visible)' );

                        return {
                                prev: fragments.length - hiddenFragments.length > 0,
                                next: !!hiddenFragments.length
                        };
                }
                else {
                        return { prev: false, next: false };
                }

        }

        /**
         * Enforces origin-specific format rules for embedded media.
         */
        function formatEmbeddedContent() {

                var _appendParamToIframeSource = function( sourceAttribute, sourceURL, param ) {
                        toArray( dom.slides.querySelectorAll( 'iframe['+ sourceAttribute +'*="'+ sourceURL +'"]' ) ).forEach( function( el ) {
                                var src = el.getAttribute( sourceAttribute );
                                if( src && src.indexOf( param ) === -1 ) {
                                        el.setAttribute( sourceAttribute, src + ( !/\?/.test( src ) ? '?' : '&' ) + param );
                                }
                        });
                };

                // YouTube frames must include "?enablejsapi=1"
                _appendParamToIframeSource( 'src', 'youtube.com/embed/', 'enablejsapi=1' );
                _appendParamToIframeSource( 'data-src', 'youtube.com/embed/', 'enablejsapi=1' );

                // Vimeo frames must include "?api=1"
                _appendParamToIframeSource( 'src', 'player.vimeo.com/', 'api=1' );
                _appendParamToIframeSource( 'data-src', 'player.vimeo.com/', 'api=1' );

                // Always show media controls on mobile devices
                if( isMobileDevice ) {
                        toArray( dom.slides.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {
                                el.controls = true;
                        } );
                }

        }

        /**
         * Start playback of any embedded content inside of
         * the given element.
         *
         * @param {HTMLElement} element
         */
        function startEmbeddedContent( element ) {

                if( element && !isSpeakerNotes() ) {

                        // Restart GIFs
                        toArray( element.querySelectorAll( 'img[src$=".gif"]' ) ).forEach( function( el ) {
                                // Setting the same unchanged source like this was confirmed
                                // to work in Chrome, FF & Safari
                                el.setAttribute( 'src', el.getAttribute( 'src' ) );
                        } );

                        // HTML5 media elements
                        toArray( element.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {
                                if( closestParent( el, '.fragment' ) && !closestParent( el, '.fragment.visible' ) ) {
                                        return;
                                }

                                // Prefer an explicit global autoplay setting
                                var autoplay = config.autoPlayMedia;

                                // If no global setting is available, fall back on the element's
                                // own autoplay setting
                                if( typeof autoplay !== 'boolean' ) {
                                        autoplay = el.hasAttribute( 'data-autoplay' ) || !!closestParent( el, '.slide-background' );
                                }

                                if( autoplay && typeof el.play === 'function' ) {

                                        if( el.readyState > 1 ) {
                                                startEmbeddedMedia( { target: el } );
                                        }
                                        else {
                                                el.removeEventListener( 'loadeddata', startEmbeddedMedia ); // remove first to avoid dupes
                                                el.addEventListener( 'loadeddata', startEmbeddedMedia );
                                        }

                                }
                        } );

                        // Normal iframes
                        toArray( element.querySelectorAll( 'iframe[src]' ) ).forEach( function( el ) {
                                if( closestParent( el, '.fragment' ) && !closestParent( el, '.fragment.visible' ) ) {
                                        return;
                                }

                                startEmbeddedIframe( { target: el } );
                        } );

                        // Lazy loading iframes
                        toArray( element.querySelectorAll( 'iframe[data-src]' ) ).forEach( function( el ) {
                                if( closestParent( el, '.fragment' ) && !closestParent( el, '.fragment.visible' ) ) {
                                        return;
                                }

                                if( el.getAttribute( 'src' ) !== el.getAttribute( 'data-src' ) ) {
                                        el.removeEventListener( 'load', startEmbeddedIframe ); // remove first to avoid dupes
                                        el.addEventListener( 'load', startEmbeddedIframe );
                                        el.setAttribute( 'src', el.getAttribute( 'data-src' ) );
                                }
                        } );

                }

        }

        /**
         * Starts playing an embedded video/audio element after
         * it has finished loading.
         *
         * @param {object} event
         */
        function startEmbeddedMedia( event ) {

                var isAttachedToDOM = !!closestParent( event.target, 'html' ),
                        isVisible               = !!closestParent( event.target, '.present' );

                if( isAttachedToDOM && isVisible ) {
                        event.target.currentTime = 0;
                        event.target.play();
                }

                event.target.removeEventListener( 'loadeddata', startEmbeddedMedia );

        }

        /**
         * "Starts" the content of an embedded iframe using the
         * postMessage API.
         *
         * @param {object} event
         */
        function startEmbeddedIframe( event ) {

                var iframe = event.target;

                if( iframe && iframe.contentWindow ) {

                        var isAttachedToDOM = !!closestParent( event.target, 'html' ),
                                isVisible               = !!closestParent( event.target, '.present' );

                        if( isAttachedToDOM && isVisible ) {

                                // Prefer an explicit global autoplay setting
                                var autoplay = config.autoPlayMedia;

                                // If no global setting is available, fall back on the element's
                                // own autoplay setting
                                if( typeof autoplay !== 'boolean' ) {
                                        autoplay = iframe.hasAttribute( 'data-autoplay' ) || !!closestParent( iframe, '.slide-background' );
                                }

                                // YouTube postMessage API
                                if( /youtube\.com\/embed\//.test( iframe.getAttribute( 'src' ) ) && autoplay ) {
                                        iframe.contentWindow.postMessage( '{"event":"command","func":"playVideo","args":""}', '*' );
                                }
                                // Vimeo postMessage API
                                else if( /player\.vimeo\.com\//.test( iframe.getAttribute( 'src' ) ) && autoplay ) {
                                        iframe.contentWindow.postMessage( '{"method":"play"}', '*' );
                                }
                                // Generic postMessage API
                                else {
                                        iframe.contentWindow.postMessage( 'slide:start', '*' );
                                }

                        }

                }

        }

        /**
         * Stop playback of any embedded content inside of
         * the targeted slide.
         *
         * @param {HTMLElement} element
         */
        function stopEmbeddedContent( element, options ) {

                options = extend( {
                        // Defaults
                        unloadIframes: true
                }, options || {} );

                if( element && element.parentNode ) {
                        // HTML5 media elements
                        toArray( element.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {
                                if( !el.hasAttribute( 'data-ignore' ) && typeof el.pause === 'function' ) {
                                        el.setAttribute('data-paused-by-reveal', '');
                                        el.pause();
                                }
                        } );

                        // Generic postMessage API for non-lazy loaded iframes
                        toArray( element.querySelectorAll( 'iframe' ) ).forEach( function( el ) {
                                if( el.contentWindow ) el.contentWindow.postMessage( 'slide:stop', '*' );
                                el.removeEventListener( 'load', startEmbeddedIframe );
                        });

                        // YouTube postMessage API
                        toArray( element.querySelectorAll( 'iframe[src*="youtube.com/embed/"]' ) ).forEach( function( el ) {
                                if( !el.hasAttribute( 'data-ignore' ) && el.contentWindow && typeof el.contentWindow.postMessage === 'function' ) {
                                        el.contentWindow.postMessage( '{"event":"command","func":"pauseVideo","args":""}', '*' );
                                }
                        });

                        // Vimeo postMessage API
                        toArray( element.querySelectorAll( 'iframe[src*="player.vimeo.com/"]' ) ).forEach( function( el ) {
                                if( !el.hasAttribute( 'data-ignore' ) && el.contentWindow && typeof el.contentWindow.postMessage === 'function' ) {
                                        el.contentWindow.postMessage( '{"method":"pause"}', '*' );
                                }
                        });

                        if( options.unloadIframes === true ) {
                                // Unload lazy-loaded iframes
                                toArray( element.querySelectorAll( 'iframe[data-src]' ) ).forEach( function( el ) {
                                        // Only removing the src doesn't actually unload the frame
                                        // in all browsers (Firefox) so we set it to blank first
                                        el.setAttribute( 'src', 'about:blank' );
                                        el.removeAttribute( 'src' );
                                } );
                        }
                }

        }

        /**
         * Returns the number of past slides. This can be used as a global
         * flattened index for slides.
         *
         * @return {number} Past slide count
         */
        function getSlidePastCount() {

                var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );

                // The number of past slides
                var pastCount = 0;

                // Step through all slides and count the past ones
                mainLoop: for( var i = 0; i < horizontalSlides.length; i++ ) {

                        var horizontalSlide = horizontalSlides[i];
                        var verticalSlides = toArray( horizontalSlide.querySelectorAll( 'section' ) );

                        for( var j = 0; j < verticalSlides.length; j++ ) {

                                // Stop as soon as we arrive at the present
                                if( verticalSlides[j].classList.contains( 'present' ) ) {
                                        break mainLoop;
                                }

                                pastCount++;

                        }

                        // Stop as soon as we arrive at the present
                        if( horizontalSlide.classList.contains( 'present' ) ) {
                                break;
                        }

                        // Don't count the wrapping section for vertical slides
                        if( horizontalSlide.classList.contains( 'stack' ) === false ) {
                                pastCount++;
                        }

                }

                return pastCount;

        }

        /**
         * Returns a value ranging from 0-1 that represents
         * how far into the presentation we have navigated.
         *
         * @return {number}
         */
        function getProgress() {

                // The number of past and total slides
                var totalCount = getTotalSlides();
                var pastCount = getSlidePastCount();

                if( currentSlide ) {

                        var allFragments = currentSlide.querySelectorAll( '.fragment' );

                        // If there are fragments in the current slide those should be
                        // accounted for in the progress.
                        if( allFragments.length > 0 ) {
                                var visibleFragments = currentSlide.querySelectorAll( '.fragment.visible' );

                                // This value represents how big a portion of the slide progress
                                // that is made up by its fragments (0-1)
                                var fragmentWeight = 0.9;

                                // Add fragment progress to the past slide count
                                pastCount += ( visibleFragments.length / allFragments.length ) * fragmentWeight;
                        }

                }

                return pastCount / ( totalCount - 1 );

        }

        /**
         * Checks if this presentation is running inside of the
         * speaker notes window.
         *
         * @return {boolean}
         */
        function isSpeakerNotes() {

                return !!window.location.search.match( /receiver/gi );

        }

        /**
         * Reads the current URL (hash) and navigates accordingly.
         */
        function readURL() {

                var hash = window.location.hash;

                // Attempt to parse the hash as either an index or name
                var bits = hash.slice( 2 ).split( '/' ),
                        name = hash.replace( /#|\//gi, '' );

                // If the first bit is invalid and there is a name we can
                // assume that this is a named link
                if( isNaN( parseInt( bits[0], 10 ) ) && name.length ) {
                        var element;

                        // Ensure the named link is a valid HTML ID attribute
                        if( /^[a-zA-Z][\w:.-]*$/.test( name ) ) {
                                // Find the slide with the specified ID
                                element = document.getElementById( name );
                        }

                        if( element ) {
                                // Find the position of the named slide and navigate to it
                                var indices = Reveal.getIndices( element );
                                slide( indices.h, indices.v );
                        }
                        // If the slide doesn't exist, navigate to the current slide
                        else {
                                slide( indexh || 0, indexv || 0 );
                        }
                }
                else {
                        // Read the index components of the hash
                        var h = parseInt( bits[0], 10 ) || 0,
                                v = parseInt( bits[1], 10 ) || 0;

                        if( h !== indexh || v !== indexv ) {
                                slide( h, v );
                        }
                }

        }

        /**
         * Updates the page URL (hash) to reflect the current
         * state.
         *
         * @param {number} delay The time in ms to wait before
         * writing the hash
         */
        function writeURL( delay ) {

                if( config.history ) {

                        // Make sure there's never more than one timeout running
                        clearTimeout( writeURLTimeout );

                        // If a delay is specified, timeout this call
                        if( typeof delay === 'number' ) {
                                writeURLTimeout = setTimeout( writeURL, delay );
                        }
                        else if( currentSlide ) {
                                var url = '/';

                                // Attempt to create a named link based on the slide's ID
                                var id = currentSlide.getAttribute( 'id' );
                                if( id ) {
                                        id = id.replace( /[^a-zA-Z0-9\-\_\:\.]/g, '' );
                                }

                                // If the current slide has an ID, use that as a named link
                                if( typeof id === 'string' && id.length ) {
                                        url = '/' + id;
                                }
                                // Otherwise use the /h/v index
                                else {
                                        if( indexh > 0 || indexv > 0 ) url += indexh;
                                        if( indexv > 0 ) url += '/' + indexv;
                                }

                                window.location.hash = url;
                        }
                }

        }
        /**
         * Retrieves the h/v location and fragment of the current,
         * or specified, slide.
         *
         * @param {HTMLElement} [slide] If specified, the returned
         * index will be for this slide rather than the currently
         * active one
         *
         * @return {{h: number, v: number, f: number}}
         */
        function getIndices( slide ) {

                // By default, return the current indices
                var h = indexh,
                        v = indexv,
                        f;

                // If a slide is specified, return the indices of that slide
                if( slide ) {
                        var isVertical = isVerticalSlide( slide );
                        var slideh = isVertical ? slide.parentNode : slide;

                        // Select all horizontal slides
                        var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );

                        // Now that we know which the horizontal slide is, get its index
                        h = Math.max( horizontalSlides.indexOf( slideh ), 0 );

                        // Assume we're not vertical
                        v = undefined;

                        // If this is a vertical slide, grab the vertical index
                        if( isVertical ) {
                                v = Math.max( toArray( slide.parentNode.querySelectorAll( 'section' ) ).indexOf( slide ), 0 );
                        }
                }

                if( !slide && currentSlide ) {
                        var hasFragments = currentSlide.querySelectorAll( '.fragment' ).length > 0;
                        if( hasFragments ) {
                                var currentFragment = currentSlide.querySelector( '.current-fragment' );
                                if( currentFragment && currentFragment.hasAttribute( 'data-fragment-index' ) ) {
                                        f = parseInt( currentFragment.getAttribute( 'data-fragment-index' ), 10 );
                                }
                                else {
                                        f = currentSlide.querySelectorAll( '.fragment.visible' ).length - 1;
                                }
                        }
                }

                return { h: h, v: v, f: f };

        }

        /**
         * Retrieves all slides in this presentation.
         */
        function getSlides() {

                return toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ':not(.stack)' ));

        }

        /**
         * Retrieves the total number of slides in this presentation.
         *
         * @return {number}
         */
        function getTotalSlides() {

                return getSlides().length;

        }

        /**
         * Returns the slide element matching the specified index.
         *
         * @return {HTMLElement}
         */
        function getSlide( x, y ) {

                var horizontalSlide = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR )[ x ];
                var verticalSlides = horizontalSlide && horizontalSlide.querySelectorAll( 'section' );

                if( verticalSlides && verticalSlides.length && typeof y === 'number' ) {
                        return verticalSlides ? verticalSlides[ y ] : undefined;
                }

                return horizontalSlide;

        }

        /**
         * Returns the background element for the given slide.
         * All slides, even the ones with no background properties
         * defined, have a background element so as long as the
         * index is valid an element will be returned.
         *
         * @param {number} x Horizontal background index
         * @param {number} y Vertical background index
         * @return {(HTMLElement[]|*)}
         */
        function getSlideBackground( x, y ) {

                var slide = getSlide( x, y );
                if( slide ) {
                        return slide.slideBackgroundElement;
                }

                return undefined;

        }

        /**
         * Retrieves the speaker notes from a slide. Notes can be
         * defined in two ways:
         * 1. As a data-notes attribute on the slide <section>
         * 2. As an <aside class="notes"> inside of the slide
         *
         * @param {HTMLElement} [slide=currentSlide]
         * @return {(string|null)}
         */
        function getSlideNotes( slide ) {

                // Default to the current slide
                slide = slide || currentSlide;

                // Notes can be specified via the data-notes attribute...
                if( slide.hasAttribute( 'data-notes' ) ) {
                        return slide.getAttribute( 'data-notes' );
                }

                // ... or using an <aside class="notes"> element
                var notesElement = slide.querySelector( 'aside.notes' );
                if( notesElement ) {
                        return notesElement.innerHTML;
                }

                return null;

        }

        /**
         * Retrieves the current state of the presentation as
         * an object. This state can then be restored at any
         * time.
         *
         * @return {{indexh: number, indexv: number, indexf: number, paused: boolean, overview: boolean}}
         */
        function getState() {

                var indices = getIndices();

                return {
                        indexh: indices.h,
                        indexv: indices.v,
                        indexf: indices.f,
                        paused: isPaused(),
                        overview: isOverview()
                };

        }

        /**
         * Restores the presentation to the given state.
         *
         * @param {object} state As generated by getState()
         * @see {@link getState} generates the parameter `state`
         */
        function setState( state ) {

                if( typeof state === 'object' ) {
                        slide( deserialize( state.indexh ), deserialize( state.indexv ), deserialize( state.indexf ) );

                        var pausedFlag = deserialize( state.paused ),
                                overviewFlag = deserialize( state.overview );

                        if( typeof pausedFlag === 'boolean' && pausedFlag !== isPaused() ) {
                                togglePause( pausedFlag );
                        }

                        if( typeof overviewFlag === 'boolean' && overviewFlag !== isOverview() ) {
                                toggleOverview( overviewFlag );
                        }
                }

        }

        /**
         * Return a sorted fragments list, ordered by an increasing
         * "data-fragment-index" attribute.
         *
         * Fragments will be revealed in the order that they are returned by
         * this function, so you can use the index attributes to control the
         * order of fragment appearance.
         *
         * To maintain a sensible default fragment order, fragments are presumed
         * to be passed in document order. This function adds a "fragment-index"
         * attribute to each node if such an attribute is not already present,
         * and sets that attribute to an integer value which is the position of
         * the fragment within the fragments list.
         *
         * @param {object[]|*} fragments
         * @return {object[]} sorted Sorted array of fragments
         */
        function sortFragments( fragments ) {

                fragments = toArray( fragments );

                var ordered = [],
                        unordered = [],
                        sorted = [];

                // Group ordered and unordered elements
                fragments.forEach( function( fragment, i ) {
                        if( fragment.hasAttribute( 'data-fragment-index' ) ) {
                                var index = parseInt( fragment.getAttribute( 'data-fragment-index' ), 10 );

                                if( !ordered[index] ) {
                                        ordered[index] = [];
                                }

                                ordered[index].push( fragment );
                        }
                        else {
                                unordered.push( [ fragment ] );
                        }
                } );

                // Append fragments without explicit indices in their
                // DOM order
                ordered = ordered.concat( unordered );

                // Manually count the index up per group to ensure there
                // are no gaps
                var index = 0;

                // Push all fragments in their sorted order to an array,
                // this flattens the groups
                ordered.forEach( function( group ) {
                        group.forEach( function( fragment ) {
                                sorted.push( fragment );
                                fragment.setAttribute( 'data-fragment-index', index );
                        } );

                        index ++;
                } );

                return sorted;

        }

        /**
         * Navigate to the specified slide fragment.
         *
         * @param {?number} index The index of the fragment that
         * should be shown, -1 means all are invisible
         * @param {number} offset Integer offset to apply to the
         * fragment index
         *
         * @return {boolean} true if a change was made in any
         * fragments visibility as part of this call
         */
        function navigateFragment( index, offset ) {

                if( currentSlide && config.fragments ) {

                        var fragments = sortFragments( currentSlide.querySelectorAll( '.fragment' ) );
                        if( fragments.length ) {

                                // If no index is specified, find the current
                                if( typeof index !== 'number' ) {
                                        var lastVisibleFragment = sortFragments( currentSlide.querySelectorAll( '.fragment.visible' ) ).pop();

                                        if( lastVisibleFragment ) {
                                                index = parseInt( lastVisibleFragment.getAttribute( 'data-fragment-index' ) || 0, 10 );
                                        }
                                        else {
                                                index = -1;
                                        }
                                }

                                // If an offset is specified, apply it to the index
                                if( typeof offset === 'number' ) {
                                        index += offset;
                                }

                                var fragmentsShown = [],
                                        fragmentsHidden = [];

                                toArray( fragments ).forEach( function( element, i ) {

                                        if( element.hasAttribute( 'data-fragment-index' ) ) {
                                                i = parseInt( element.getAttribute( 'data-fragment-index' ), 10 );
                                        }

                                        // Visible fragments
                                        if( i <= index ) {
                                                if( !element.classList.contains( 'visible' ) ) fragmentsShown.push( element );
                                                element.classList.add( 'visible' );
                                                element.classList.remove( 'current-fragment' );

                                                // Announce the fragments one by one to the Screen Reader
                                                dom.statusDiv.textContent = getStatusText( element );

                                                if( i === index ) {
                                                        element.classList.add( 'current-fragment' );
                                                        startEmbeddedContent( element );
                                                }
                                        }
                                        // Hidden fragments
                                        else {
                                                if( element.classList.contains( 'visible' ) ) fragmentsHidden.push( element );
                                                element.classList.remove( 'visible' );
                                                element.classList.remove( 'current-fragment' );
                                        }

                                } );

                                if( fragmentsHidden.length ) {
                                        dispatchEvent( 'fragmenthidden', { fragment: fragmentsHidden[0], fragments: fragmentsHidden } );
                                }

                                if( fragmentsShown.length ) {
                                        dispatchEvent( 'fragmentshown', { fragment: fragmentsShown[0], fragments: fragmentsShown } );
                                }

                                updateControls();
                                updateProgress();

                                return !!( fragmentsShown.length || fragmentsHidden.length );

                        }

                }

                return false;

        }

        /**
         * Navigate to the next slide fragment.
         *
         * @return {boolean} true if there was a next fragment,
         * false otherwise
         */
        function nextFragment() {

                return navigateFragment( null, 1 );

        }

        /**
         * Navigate to the previous slide fragment.
         *
         * @return {boolean} true if there was a previous fragment,
         * false otherwise
         */
        function previousFragment() {

                return navigateFragment( null, -1 );

        }

        /**
         * Cues a new automated slide if enabled in the config.
         */
        function cueAutoSlide() {

                cancelAutoSlide();

                if( currentSlide && config.autoSlide !== false ) {

                        var fragment = currentSlide.querySelector( '.current-fragment' );

                        // When the slide first appears there is no "current" fragment so
                        // we look for a data-autoslide timing on the first fragment
                        if( !fragment ) fragment = currentSlide.querySelector( '.fragment' );

                        var fragmentAutoSlide = fragment ? fragment.getAttribute( 'data-autoslide' ) : null;
                        var parentAutoSlide = currentSlide.parentNode ? currentSlide.parentNode.getAttribute( 'data-autoslide' ) : null;
                        var slideAutoSlide = currentSlide.getAttribute( 'data-autoslide' );

                        // Pick value in the following priority order:
                        // 1. Current fragment's data-autoslide
                        // 2. Current slide's data-autoslide
                        // 3. Parent slide's data-autoslide
                        // 4. Global autoSlide setting
                        if( fragmentAutoSlide ) {
                                autoSlide = parseInt( fragmentAutoSlide, 10 );
                        }
                        else if( slideAutoSlide ) {
                                autoSlide = parseInt( slideAutoSlide, 10 );
                        }
                        else if( parentAutoSlide ) {
                                autoSlide = parseInt( parentAutoSlide, 10 );
                        }
                        else {
                                autoSlide = config.autoSlide;
                        }

                        // If there are media elements with data-autoplay,
                        // automatically set the autoSlide duration to the
                        // length of that media. Not applicable if the slide
                        // is divided up into fragments.
                        // playbackRate is accounted for in the duration.
                        if( currentSlide.querySelectorAll( '.fragment' ).length === 0 ) {
                                toArray( currentSlide.querySelectorAll( 'video, audio' ) ).forEach( function( el ) {
                                        if( el.hasAttribute( 'data-autoplay' ) ) {
                                                if( autoSlide && (el.duration * 1000 / el.playbackRate ) > autoSlide ) {
                                                        autoSlide = ( el.duration * 1000 / el.playbackRate ) + 1000;
                                                }
                                        }
                                } );
                        }

                        // Cue the next auto-slide if:
                        // - There is an autoSlide value
                        // - Auto-sliding isn't paused by the user
                        // - The presentation isn't paused
                        // - The overview isn't active
                        // - The presentation isn't over
                        if( autoSlide && !autoSlidePaused && !isPaused() && !isOverview() && ( !Reveal.isLastSlide() || availableFragments().next || config.loop === true ) ) {
                                autoSlideTimeout = setTimeout( function() {
                                        typeof config.autoSlideMethod === 'function' ? config.autoSlideMethod() : navigateNext();
                                        cueAutoSlide();
                                }, autoSlide );
                                autoSlideStartTime = Date.now();
                        }

                        if( autoSlidePlayer ) {
                                autoSlidePlayer.setPlaying( autoSlideTimeout !== -1 );
                        }

                }

        }

        /**
         * Cancels any ongoing request to auto-slide.
         */
        function cancelAutoSlide() {

                clearTimeout( autoSlideTimeout );
                autoSlideTimeout = -1;

        }

        function pauseAutoSlide() {

                if( autoSlide && !autoSlidePaused ) {
                        autoSlidePaused = true;
                        dispatchEvent( 'autoslidepaused' );
                        clearTimeout( autoSlideTimeout );

                        if( autoSlidePlayer ) {
                                autoSlidePlayer.setPlaying( false );
                        }
                }

        }

        function resumeAutoSlide() {

                if( autoSlide && autoSlidePaused ) {
                        autoSlidePaused = false;
                        dispatchEvent( 'autoslideresumed' );
                        cueAutoSlide();
                }

        }

        function navigateLeft() {

                // Reverse for RTL
                if( config.rtl ) {
                        if( ( isOverview() || nextFragment() === false ) && availableRoutes().left ) {
                                slide( indexh + 1 );
                        }
                }
                // Normal navigation
                else if( ( isOverview() || previousFragment() === false ) && availableRoutes().left ) {
                        slide( indexh - 1 );
                }

        }

        function navigateRight() {

                hasNavigatedRight = true;

                // Reverse for RTL
                if( config.rtl ) {
                        if( ( isOverview() || previousFragment() === false ) && availableRoutes().right ) {
                                slide( indexh - 1 );
                        }
                }
                // Normal navigation
                else if( ( isOverview() || nextFragment() === false ) && availableRoutes().right ) {
                        slide( indexh + 1 );
                }

        }

        function navigateUp() {

                // Prioritize hiding fragments
                if( ( isOverview() || previousFragment() === false ) && availableRoutes().up ) {
                        slide( indexh, indexv - 1 );
                }

        }

        function navigateDown() {

                hasNavigatedDown = true;

                // Prioritize revealing fragments
                if( ( isOverview() || nextFragment() === false ) && availableRoutes().down ) {
                        slide( indexh, indexv + 1 );
                }

        }

        /**
         * Navigates backwards, prioritized in the following order:
         * 1) Previous fragment
         * 2) Previous vertical slide
         * 3) Previous horizontal slide
         */
        function navigatePrev() {

                // Prioritize revealing fragments
                if( previousFragment() === false ) {
                        if( availableRoutes().up ) {
                                navigateUp();
                        }
                        else {
                                // Fetch the previous horizontal slide, if there is one
                                var previousSlide;

                                if( config.rtl ) {
                                        previousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.future' ) ).pop();
                                }
                                else {
                                        previousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.past' ) ).pop();
                                }

                                if( previousSlide ) {
                                        var v = ( previousSlide.querySelectorAll( 'section' ).length - 1 ) || undefined;
                                        var h = indexh - 1;
                                        slide( h, v );
                                }
                        }
                }

        }

        /**
         * The reverse of #navigatePrev().
         */
        function navigateNext() {

                hasNavigatedRight = true;
                hasNavigatedDown = true;

                // Prioritize revealing fragments
                if( nextFragment() === false ) {
                        if( availableRoutes().down ) {
                                navigateDown();
                        }
                        else if( config.rtl ) {
                                navigateLeft();
                        }
                        else {
                                navigateRight();
                        }
                }

        }

        /**
         * Checks if the target element prevents the triggering of
         * swipe navigation.
         */
        function isSwipePrevented( target ) {

                while( target && typeof target.hasAttribute === 'function' ) {
                        if( target.hasAttribute( 'data-prevent-swipe' ) ) return true;
                        target = target.parentNode;
                }

                return false;

        }


        // --------------------------------------------------------------------//
        // ----------------------------- EVENTS -------------------------------//
        // --------------------------------------------------------------------//

        /**
         * Called by all event handlers that are based on user
         * input.
         *
         * @param {object} [event]
         */
        function onUserInput( event ) {

                if( config.autoSlideStoppable ) {
                        pauseAutoSlide();
                }

        }

        /**
         * Handler for the document level 'keypress' event.
         *
         * @param {object} event
         */
        function onDocumentKeyPress( event ) {

                // Check if the pressed key is question mark
                if( event.shiftKey && event.charCode === 63 ) {
                        toggleHelp();
                }

        }

        /**
         * Handler for the document level 'keydown' event.
         *
         * @param {object} event
         */
        function onDocumentKeyDown( event ) {

                // If there's a condition specified and it returns false,
                // ignore this event
                if( typeof config.keyboardCondition === 'function' && config.keyboardCondition() === false ) {
                        return true;
                }

                // Remember if auto-sliding was paused so we can toggle it
                var autoSlideWasPaused = autoSlidePaused;

                onUserInput( event );

                // Check if there's a focused element that could be using
                // the keyboard
                var activeElementIsCE = document.activeElement && document.activeElement.contentEditable !== 'inherit';
                var activeElementIsInput = document.activeElement && document.activeElement.tagName && /input|textarea/i.test( document.activeElement.tagName );
                var activeElementIsNotes = document.activeElement && document.activeElement.className && /speaker-notes/i.test( document.activeElement.className);

                // Disregard the event if there's a focused element or a
                // keyboard modifier key is present
                if( activeElementIsCE || activeElementIsInput || activeElementIsNotes || (event.shiftKey && event.keyCode !== 32) || event.altKey || event.ctrlKey || event.metaKey ) return;

                // While paused only allow resume keyboard events; 'b', 'v', '.'
                var resumeKeyCodes = [66,86,190,191];
                var key;

                // Custom key bindings for togglePause should be able to resume
                if( typeof config.keyboard === 'object' ) {
                        for( key in config.keyboard ) {
                                if( config.keyboard[key] === 'togglePause' ) {
                                        resumeKeyCodes.push( parseInt( key, 10 ) );
                                }
                        }
                }

                if( isPaused() && resumeKeyCodes.indexOf( event.keyCode ) === -1 ) {
                        return false;
                }

                var triggered = false;

                // 1. User defined key bindings
                if( typeof config.keyboard === 'object' ) {

                        for( key in config.keyboard ) {

                                // Check if this binding matches the pressed key
                                if( parseInt( key, 10 ) === event.keyCode ) {

                                        var value = config.keyboard[ key ];

                                        // Callback function
                                        if( typeof value === 'function' ) {
                                                value.apply( null, [ event ] );
                                        }
                                        // String shortcuts to reveal.js API
                                        else if( typeof value === 'string' && typeof Reveal[ value ] === 'function' ) {
                                                Reveal[ value ].call();
                                        }

                                        triggered = true;

                                }

                        }

                }

                // 2. System defined key bindings
                if( triggered === false ) {

                        // Assume true and try to prove false
                        triggered = true;

                        switch( event.keyCode ) {
                                // p, page up
                                case 80: case 33: navigatePrev(); break;
                                // n, page down
                                case 78: case 34: navigateNext(); break;
                                // h, left
                                case 72: case 37: navigateLeft(); break;
                                // l, right
                                case 76: case 39: navigateRight(); break;
                                // k, up
                                case 75: case 38: navigateUp(); break;
                                // j, down
                                case 74: case 40: navigateDown(); break;
                                // home
                                case 36: slide( 0 ); break;
                                // end
                                case 35: slide( Number.MAX_VALUE ); break;
                                // space
                                case 32: isOverview() ? deactivateOverview() : event.shiftKey ? navigatePrev() : navigateNext(); break;
                                // return
                                case 13: isOverview() ? deactivateOverview() : triggered = false; break;
                                // two-spot, semicolon, b, v, period, Logitech presenter tools "black screen" button
                                case 58: case 59: case 66: case 86: case 190: case 191: togglePause(); break;
                                // f
                                case 70: enterFullscreen(); break;
                                // a
                                case 65: if ( config.autoSlideStoppable ) toggleAutoSlide( autoSlideWasPaused ); break;
                                default:
                                        triggered = false;
                        }

                }

                // If the input resulted in a triggered action we should prevent
                // the browsers default behavior
                if( triggered ) {
                        event.preventDefault && event.preventDefault();
                }
                // ESC or O key
                else if ( ( event.keyCode === 27 || event.keyCode === 79 ) && features.transforms3d ) {
                        if( dom.overlay ) {
                                closeOverlay();
                        }
                        else {
                                toggleOverview();
                        }

                        event.preventDefault && event.preventDefault();
                }

                // If auto-sliding is enabled we need to cue up
                // another timeout
                cueAutoSlide();

        }

        /**
         * Handler for the 'touchstart' event, enables support for
         * swipe and pinch gestures.
         *
         * @param {object} event
         */
        function onTouchStart( event ) {

                if( isSwipePrevented( event.target ) ) return true;

                touch.startX = event.touches[0].clientX;
                touch.startY = event.touches[0].clientY;
                touch.startCount = event.touches.length;

                // If there's two touches we need to memorize the distance
                // between those two points to detect pinching
                if( event.touches.length === 2 && config.overview ) {
                        touch.startSpan = distanceBetween( {
                                x: event.touches[1].clientX,
                                y: event.touches[1].clientY
                        }, {
                                x: touch.startX,
                                y: touch.startY
                        } );
                }

        }

        /**
         * Handler for the 'touchmove' event.
         *
         * @param {object} event
         */
        function onTouchMove( event ) {

                if( isSwipePrevented( event.target ) ) return true;

                // Each touch should only trigger one action
                if( !touch.captured ) {
                        onUserInput( event );

                        var currentX = event.touches[0].clientX;
                        var currentY = event.touches[0].clientY;

                        // If the touch started with two points and still has
                        // two active touches; test for the pinch gesture
                        if( event.touches.length === 2 && touch.startCount === 2 && config.overview ) {

                                // The current distance in pixels between the two touch points
                                var currentSpan = distanceBetween( {
                                        x: event.touches[1].clientX,
                                        y: event.touches[1].clientY
                                }, {
                                        x: touch.startX,
                                        y: touch.startY
                                } );

                                // If the span is larger than the desire amount we've got
                                // ourselves a pinch
                                if( Math.abs( touch.startSpan - currentSpan ) > touch.threshold ) {
                                        touch.captured = true;

                                        if( currentSpan < touch.startSpan ) {
                                                activateOverview();
                                        }
                                        else {
                                                deactivateOverview();
                                        }
                                }

                                event.preventDefault();

                        }
                        // There was only one touch point, look for a swipe
                        else if( event.touches.length === 1 && touch.startCount !== 2 ) {

                                var deltaX = currentX - touch.startX,
                                        deltaY = currentY - touch.startY;

                                if( deltaX > touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {
                                        touch.captured = true;
                                        navigateLeft();
                                }
                                else if( deltaX < -touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {
                                        touch.captured = true;
                                        navigateRight();
                                }
                                else if( deltaY > touch.threshold ) {
                                        touch.captured = true;
                                        navigateUp();
                                }
                                else if( deltaY < -touch.threshold ) {
                                        touch.captured = true;
                                        navigateDown();
                                }

                                // If we're embedded, only block touch events if they have
                                // triggered an action
                                if( config.embedded ) {
                                        if( touch.captured || isVerticalSlide( currentSlide ) ) {
                                                event.preventDefault();
                                        }
                                }
                                // Not embedded? Block them all to avoid needless tossing
                                // around of the viewport in iOS
                                else {
                                        event.preventDefault();
                                }

                        }
                }
                // There's a bug with swiping on some Android devices unless
                // the default action is always prevented
                else if( UA.match( /android/gi ) ) {
                        event.preventDefault();
                }

        }

        /**
         * Handler for the 'touchend' event.
         *
         * @param {object} event
         */
        function onTouchEnd( event ) {

                touch.captured = false;

        }

        /**
         * Convert pointer down to touch start.
         *
         * @param {object} event
         */
        function onPointerDown( event ) {

                if( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === "touch" ) {
                        event.touches = [{ clientX: event.clientX, clientY: event.clientY }];
                        onTouchStart( event );
                }

        }

        /**
         * Convert pointer move to touch move.
         *
         * @param {object} event
         */
        function onPointerMove( event ) {

                if( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === "touch" )  {
                        event.touches = [{ clientX: event.clientX, clientY: event.clientY }];
                        onTouchMove( event );
                }

        }

        /**
         * Convert pointer up to touch end.
         *
         * @param {object} event
         */
        function onPointerUp( event ) {

                if( event.pointerType === event.MSPOINTER_TYPE_TOUCH || event.pointerType === "touch" )  {
                        event.touches = [{ clientX: event.clientX, clientY: event.clientY }];
                        onTouchEnd( event );
                }

        }

        /**
         * Handles mouse wheel scrolling, throttled to avoid skipping
         * multiple slides.
         *
         * @param {object} event
         */
        function onDocumentMouseScroll( event ) {

                if( Date.now() - lastMouseWheelStep > 600 ) {

                        lastMouseWheelStep = Date.now();

                        var delta = event.detail || -event.wheelDelta;
                        if( delta > 0 ) {
                                navigateNext();
                        }
                        else if( delta < 0 ) {
                                navigatePrev();
                        }

                }

        }

        /**
         * Clicking on the progress bar results in a navigation to the
         * closest approximate horizontal slide using this equation:
         *
         * ( clickX / presentationWidth ) * numberOfSlides
         *
         * @param {object} event
         */
        function onProgressClicked( event ) {

                onUserInput( event );

                event.preventDefault();

                var slidesTotal = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ).length;
                var slideIndex = Math.floor( ( event.clientX / dom.wrapper.offsetWidth ) * slidesTotal );

                if( config.rtl ) {
                        slideIndex = slidesTotal - slideIndex;
                }

                slide( slideIndex );

        }

        /**
         * Event handler for navigation control buttons.
         */
        function onNavigateLeftClicked( event ) { event.preventDefault(); onUserInput(); navigateLeft(); }
        function onNavigateRightClicked( event ) { event.preventDefault(); onUserInput(); navigateRight(); }
        function onNavigateUpClicked( event ) { event.preventDefault(); onUserInput(); navigateUp(); }
        function onNavigateDownClicked( event ) { event.preventDefault(); onUserInput(); navigateDown(); }
        function onNavigatePrevClicked( event ) { event.preventDefault(); onUserInput(); navigatePrev(); }
        function onNavigateNextClicked( event ) { event.preventDefault(); onUserInput(); navigateNext(); }

        /**
         * Handler for the window level 'hashchange' event.
         *
         * @param {object} [event]
         */
        function onWindowHashChange( event ) {

                readURL();

        }

        /**
         * Handler for the window level 'resize' event.
         *
         * @param {object} [event]
         */
        function onWindowResize( event ) {

                layout();

        }

        /**
         * Handle for the window level 'visibilitychange' event.
         *
         * @param {object} [event]
         */
        function onPageVisibilityChange( event ) {

                var isHidden =  document.webkitHidden ||
                                                document.msHidden ||
                                                document.hidden;

                // If, after clicking a link or similar and we're coming back,
                // focus the document.body to ensure we can use keyboard shortcuts
                if( isHidden === false && document.activeElement !== document.body ) {
                        // Not all elements support .blur() - SVGs among them.
                        if( typeof document.activeElement.blur === 'function' ) {
                                document.activeElement.blur();
                        }
                        document.body.focus();
                }

        }

        /**
         * Invoked when a slide is and we're in the overview.
         *
         * @param {object} event
         */
        function onOverviewSlideClicked( event ) {

                // TODO There's a bug here where the event listeners are not
                // removed after deactivating the overview.
                if( eventsAreBound && isOverview() ) {
                        event.preventDefault();

                        var element = event.target;

                        while( element && !element.nodeName.match( /section/gi ) ) {
                                element = element.parentNode;
                        }

                        if( element && !element.classList.contains( 'disabled' ) ) {

                                deactivateOverview();

                                if( element.nodeName.match( /section/gi ) ) {
                                        var h = parseInt( element.getAttribute( 'data-index-h' ), 10 ),
                                                v = parseInt( element.getAttribute( 'data-index-v' ), 10 );

                                        slide( h, v );
                                }

                        }
                }

        }

        /**
         * Handles clicks on links that are set to preview in the
         * iframe overlay.
         *
         * @param {object} event
         */
        function onPreviewLinkClicked( event ) {

                if( event.currentTarget && event.currentTarget.hasAttribute( 'href' ) ) {
                        var url = event.currentTarget.getAttribute( 'href' );
                        if( url ) {
                                showPreview( url );
                                event.preventDefault();
                        }
                }

        }

        /**
         * Handles click on the auto-sliding controls element.
         *
         * @param {object} [event]
         */
        function onAutoSlidePlayerClick( event ) {

                // Replay
                if( Reveal.isLastSlide() && config.loop === false ) {
                        slide( 0, 0 );
                        resumeAutoSlide();
                }
                // Resume
                else if( autoSlidePaused ) {
                        resumeAutoSlide();
                }
                // Pause
                else {
                        pauseAutoSlide();
                }

        }


        // --------------------------------------------------------------------//
        // ------------------------ PLAYBACK COMPONENT ------------------------//
        // --------------------------------------------------------------------//


        /**
         * Constructor for the playback component, which displays
         * play/pause/progress controls.
         *
         * @param {HTMLElement} container The component will append
         * itself to this
         * @param {function} progressCheck A method which will be
         * called frequently to get the current progress on a range
         * of 0-1
         */
        function Playback( container, progressCheck ) {

                // Cosmetics
                this.diameter = 100;
                this.diameter2 = this.diameter/2;
                this.thickness = 6;

                // Flags if we are currently playing
                this.playing = false;

                // Current progress on a 0-1 range
                this.progress = 0;

                // Used to loop the animation smoothly
                this.progressOffset = 1;

                this.container = container;
                this.progressCheck = progressCheck;

                this.canvas = document.createElement( 'canvas' );
                this.canvas.className = 'playback';
                this.canvas.width = this.diameter;
                this.canvas.height = this.diameter;
                this.canvas.style.width = this.diameter2 + 'px';
                this.canvas.style.height = this.diameter2 + 'px';
                this.context = this.canvas.getContext( '2d' );

                this.container.appendChild( this.canvas );

                this.render();

        }

        /**
         * @param value
         */
        Playback.prototype.setPlaying = function( value ) {

                var wasPlaying = this.playing;

                this.playing = value;

                // Start repainting if we weren't already
                if( !wasPlaying && this.playing ) {
                        this.animate();
                }
                else {
                        this.render();
                }

        };

        Playback.prototype.animate = function() {

                var progressBefore = this.progress;

                this.progress = this.progressCheck();

                // When we loop, offset the progress so that it eases
                // smoothly rather than immediately resetting
                if( progressBefore > 0.8 && this.progress < 0.2 ) {
                        this.progressOffset = this.progress;
                }

                this.render();

                if( this.playing ) {
                        features.requestAnimationFrameMethod.call( window, this.animate.bind( this ) );
                }

        };

        /**
         * Renders the current progress and playback state.
         */
        Playback.prototype.render = function() {

                var progress = this.playing ? this.progress : 0,
                        radius = ( this.diameter2 ) - this.thickness,
                        x = this.diameter2,
                        y = this.diameter2,
                        iconSize = 28;

                // Ease towards 1
                this.progressOffset += ( 1 - this.progressOffset ) * 0.1;

                var endAngle = ( - Math.PI / 2 ) + ( progress * ( Math.PI * 2 ) );
                var startAngle = ( - Math.PI / 2 ) + ( this.progressOffset * ( Math.PI * 2 ) );

                this.context.save();
                this.context.clearRect( 0, 0, this.diameter, this.diameter );

                // Solid background color
                this.context.beginPath();
                this.context.arc( x, y, radius + 4, 0, Math.PI * 2, false );
                this.context.fillStyle = 'rgba( 0, 0, 0, 0.4 )';
                this.context.fill();

                // Draw progress track
                this.context.beginPath();
                this.context.arc( x, y, radius, 0, Math.PI * 2, false );
                this.context.lineWidth = this.thickness;
                this.context.strokeStyle = 'rgba( 255, 255, 255, 0.2 )';
                this.context.stroke();

                if( this.playing ) {
                        // Draw progress on top of track
                        this.context.beginPath();
                        this.context.arc( x, y, radius, startAngle, endAngle, false );
                        this.context.lineWidth = this.thickness;
                        this.context.strokeStyle = '#fff';
                        this.context.stroke();
                }

                this.context.translate( x - ( iconSize / 2 ), y - ( iconSize / 2 ) );

                // Draw play/pause icons
                if( this.playing ) {
                        this.context.fillStyle = '#fff';
                        this.context.fillRect( 0, 0, iconSize / 2 - 4, iconSize );
                        this.context.fillRect( iconSize / 2 + 4, 0, iconSize / 2 - 4, iconSize );
                }
                else {
                        this.context.beginPath();
                        this.context.translate( 4, 0 );
                        this.context.moveTo( 0, 0 );
                        this.context.lineTo( iconSize - 4, iconSize / 2 );
                        this.context.lineTo( 0, iconSize );
                        this.context.fillStyle = '#fff';
                        this.context.fill();
                }

                this.context.restore();

        };

        Playback.prototype.on = function( type, listener ) {
                this.canvas.addEventListener( type, listener, false );
        };

        Playback.prototype.off = function( type, listener ) {
                this.canvas.removeEventListener( type, listener, false );
        };

        Playback.prototype.destroy = function() {

                this.playing = false;

                if( this.canvas.parentNode ) {
                        this.container.removeChild( this.canvas );
                }

        };


        // --------------------------------------------------------------------//
        // ------------------------------- API --------------------------------//
        // --------------------------------------------------------------------//


        Reveal = {
                VERSION: VERSION,

                initialize: initialize,
                configure: configure,
                sync: sync,

                // Navigation methods
                slide: slide,
                left: navigateLeft,
                right: navigateRight,
                up: navigateUp,
                down: navigateDown,
                prev: navigatePrev,
                next: navigateNext,

                // Fragment methods
                navigateFragment: navigateFragment,
                prevFragment: previousFragment,
                nextFragment: nextFragment,

                // Deprecated aliases
                navigateTo: slide,
                navigateLeft: navigateLeft,
                navigateRight: navigateRight,
                navigateUp: navigateUp,
                navigateDown: navigateDown,
                navigatePrev: navigatePrev,
                navigateNext: navigateNext,

                // Forces an update in slide layout
                layout: layout,

                // Randomizes the order of slides
                shuffle: shuffle,

                // Returns an object with the available routes as booleans (left/right/top/bottom)
                availableRoutes: availableRoutes,

                // Returns an object with the available fragments as booleans (prev/next)
                availableFragments: availableFragments,

                // Toggles a help overlay with keyboard shortcuts
                toggleHelp: toggleHelp,

                // Toggles the overview mode on/off
                toggleOverview: toggleOverview,

                // Toggles the "black screen" mode on/off
                togglePause: togglePause,

                // Toggles the auto slide mode on/off
                toggleAutoSlide: toggleAutoSlide,

                // State checks
                isOverview: isOverview,
                isPaused: isPaused,
                isAutoSliding: isAutoSliding,
                isSpeakerNotes: isSpeakerNotes,

                // Slide preloading
                loadSlide: loadSlide,
                unloadSlide: unloadSlide,

                // Adds or removes all internal event listeners (such as keyboard)
                addEventListeners: addEventListeners,
                removeEventListeners: removeEventListeners,

                // Facility for persisting and restoring the presentation state
                getState: getState,
                setState: setState,

                // Presentation progress
                getSlidePastCount: getSlidePastCount,

                // Presentation progress on range of 0-1
                getProgress: getProgress,

                // Returns the indices of the current, or specified, slide
                getIndices: getIndices,

                // Returns an Array of all slides
                getSlides: getSlides,

                // Returns the total number of slides
                getTotalSlides: getTotalSlides,

                // Returns the slide element at the specified index
                getSlide: getSlide,

                // Returns the slide background element at the specified index
                getSlideBackground: getSlideBackground,

                // Returns the speaker notes string for a slide, or null
                getSlideNotes: getSlideNotes,

                // Returns the previous slide element, may be null
                getPreviousSlide: function() {
                        return previousSlide;
                },

                // Returns the current slide element
                getCurrentSlide: function() {
                        return currentSlide;
                },

                // Returns the current scale of the presentation content
                getScale: function() {
                        return scale;
                },

                // Returns the current configuration object
                getConfig: function() {
                        return config;
                },

                // Helper method, retrieves query string as a key/value hash
                getQueryHash: function() {
                        var query = {};

                        location.search.replace( /[A-Z0-9]+?=([\w\.%-]*)/gi, function(a) {
                                query[ a.split( '=' ).shift() ] = a.split( '=' ).pop();
                        } );

                        // Basic deserialization
                        for( var i in query ) {
                                var value = query[ i ];

                                query[ i ] = deserialize( unescape( value ) );
                        }

                        return query;
                },

                // Returns true if we're currently on the first slide
                isFirstSlide: function() {
                        return ( indexh === 0 && indexv === 0 );
                },

                // Returns true if we're currently on the last slide
                isLastSlide: function() {
                        if( currentSlide ) {
                                // Does this slide has next a sibling?
                                if( currentSlide.nextElementSibling ) return false;

                                // If it's vertical, does its parent have a next sibling?
                                if( isVerticalSlide( currentSlide ) && currentSlide.parentNode.nextElementSibling ) return false;

                                return true;
                        }

                        return false;
                },

                // Checks if reveal.js has been loaded and is ready for use
                isReady: function() {
                        return loaded;
                },

                // Forward event binding to the reveal DOM element
                addEventListener: function( type, listener, useCapture ) {
                        if( 'addEventListener' in window ) {
                                ( dom.wrapper || document.querySelector( '.reveal' ) ).addEventListener( type, listener, useCapture );
                        }
                },
                removeEventListener: function( type, listener, useCapture ) {
                        if( 'addEventListener' in window ) {
                                ( dom.wrapper || document.querySelector( '.reveal' ) ).removeEventListener( type, listener, useCapture );
                        }
                },

                // Programatically triggers a keyboard event
                triggerKey: function( keyCode ) {
                        onDocumentKeyDown( { keyCode: keyCode } );
                },

                // Registers a new shortcut to include in the help overlay
                registerKeyboardShortcut: function( key, value ) {
                        keyboardShortcuts[key] = value;
                }
        };

        return Reveal;

}));

</script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: false,
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},
});
</script>
</body>
</html>
